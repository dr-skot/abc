# Autogenerated from a Treetop grammar. Edits may be lost.


# -*- coding: utf-8 -*-
# based on
# http://abcnotation.com/wiki/abc:standard:v2.1

module ABC
  include Treetop::Runtime

  def root
    @root ||= :abc_file
  end

  module AbcFile0
  end

  module AbcFile1
    def value
      @value ||= Tunebook.new(values)
    end
    def error
      "tunebook must contain at least 1 tune" if value.tunes.count == 0
    end
  end

  def _nt_abc_file
    start_index = index
    if node_cache[:abc_file].has_key?(index)
      cached = node_cache[:abc_file][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_file_header_section
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        r4 = _nt_tune_or_text_section
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(FileNode,input, i0...index, s0)
      r0.extend(AbcFile0)
      r0.extend(AbcFile1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:abc_file][start_index] = r0

    r0
  end

  module FileHeaderSection0
    def file_header
      elements[1]
    end

    def end_of_section
      elements[2]
    end
  end

  def _nt_file_header_section
    start_index = index
    if node_cache[:file_header_section].has_key?(index)
      cached = node_cache[:file_header_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_typeset_text_section
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_file_header
      s0 << r3
      if r3
        r4 = _nt_end_of_section
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FileHeaderSection0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:file_header_section][start_index] = r0

    r0
  end

  def _nt_tune_or_text_section
    start_index = index
    if node_cache[:tune_or_text_section].has_key?(index)
      cached = node_cache[:tune_or_text_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_text_section
    if r1
      r0 = r1
    else
      r2 = _nt_tune_section
      if r2
        r0 = r2
      else
        r3 = _nt_invalid_section
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:tune_or_text_section][start_index] = r0

    r0
  end

  module TuneSection0
    def tune
      elements[0]
    end

    def end_of_section
      elements[1]
    end
  end

  def _nt_tune_section
    start_index = index
    if node_cache[:tune_section].has_key?(index)
      cached = node_cache[:tune_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tune
    s0 << r1
    if r1
      r2 = _nt_end_of_section
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneSection0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_section][start_index] = r0

    r0
  end

  module TextSection0
    def free_text
      elements[0]
    end

    def end_of_section
      elements[1]
    end
  end

  def _nt_text_section
    start_index = index
    if node_cache[:text_section].has_key?(index)
      cached = node_cache[:text_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_typeset_text_section
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_free_text
      s2 << r3
      if r3
        r4 = _nt_end_of_section
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(TextSection0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:text_section][start_index] = r0

    r0
  end

  module InvalidSection0
    def end_of_line
      elements[0]
    end

    def end_of_section
      elements[1]
    end
  end

  module InvalidSection1
  end

  module InvalidSection2
    def end_of_section
      elements[1]
    end
  end

  module InvalidSection3
    def error
      "invalid section"
    end
  end

  def _nt_invalid_section
    start_index = index
    if node_cache[:invalid_section].has_key?(index)
      cached = node_cache[:invalid_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      i3 = index
      i4, s4 = index, []
      r5 = _nt_end_of_line
      s4 << r5
      if r5
        r6 = _nt_end_of_section
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(InvalidSection0)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r3 = nil
      else
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s2 << r3
      if r3
        if index < input_length
          r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("any character")
          r7 = nil
        end
        s2 << r7
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(InvalidSection1)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r8 = _nt_end_of_section
      s0 << r8
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InvalidSection2)
      r0.extend(InvalidSection3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:invalid_section][start_index] = r0

    r0
  end

  module Tune0
    def tune_header
      elements[1]
    end

  end

  module Tune1
    def value
      @value ||= Tune.new(values)
    end
  end

  def _nt_tune
    start_index = index
    if node_cache[:tune].has_key?(index)
      cached = node_cache[:tune][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_comment_line
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r3 = _nt_tune_header
      s0 << r3
      if r3
        r5 = _nt_tune_body
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(TuneNode,input, i0...index, s0)
      r0.extend(Tune0)
      r0.extend(Tune1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune][start_index] = r0

    r0
  end

  def _nt_tune_header
    start_index = index
    if node_cache[:tune_header].has_key?(index)
      cached = node_cache[:tune_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_valid_tune_header
    if r1
      r0 = r1
    else
      r2 = _nt_invalid_tune_header
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:tune_header][start_index] = r0

    r0
  end

  module ValidTuneHeader0
    def refnum_field_line
      elements[0]
    end

    def title_field_line
      elements[1]
    end

    def key_field_line
      elements[3]
    end
  end

  def _nt_valid_tune_header
    start_index = index
    if node_cache[:valid_tune_header].has_key?(index)
      cached = node_cache[:valid_tune_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_refnum_field_line
    s0 << r1
    if r1
      r2 = _nt_title_field_line
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_tune_header_line
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
        if r3
          r5 = _nt_key_field_line
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(HeaderNode,input, i0...index, s0)
      r0.extend(ValidTuneHeader0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:valid_tune_header][start_index] = r0

    r0
  end

  module InvalidTuneHeader0
    def error
      if value.fields[0].type != :refnum
        "tune header must start with a refnum (X:) field"
      elsif !value.fields[1] || value.fields[1].type != :title
        "a title (T:) field must follow refnum (X:) field in tune header"
      elsif value.fields.select { |f| f.type == :refnum }.count > 1
        "duplicate refnum (X:) field"
      else
        "invalid tune header"
      end
    end
  end

  def _nt_invalid_tune_header
    start_index = index
    if node_cache[:invalid_tune_header].has_key?(index)
      cached = node_cache[:invalid_tune_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_field_line
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(HeaderNode,input, i0...index, s0)
      r0.extend(InvalidTuneHeader0)
    end

    node_cache[:invalid_tune_header][start_index] = r0

    r0
  end

  module FileHeader0
  end

  def _nt_file_header
    start_index = index
    if node_cache[:file_header].has_key?(index)
      cached = node_cache[:file_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_comment_line
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      i3 = index
      r4 = _nt_valid_file_header
      if r4
        r3 = r4
      else
        r5 = _nt_invalid_file_header
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FileHeader0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:file_header][start_index] = r0

    r0
  end

  module ValidFileHeader0
    def file_header_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  module ValidFileHeader1
  end

  module ValidFileHeader2
    def christen
      super
      parser.globals[:file_header] = self.value
    end
  end

  def _nt_valid_file_header
    start_index = index
    if node_cache[:valid_file_header].has_key?(index)
      cached = node_cache[:valid_file_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      r3 = _nt_file_header_field
      s2 << r3
      if r3
        r4 = _nt_line_ender
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(ValidFileHeader0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      i5 = index
      r6 = _nt_end_of_section
      if r6
        @index = i5
        r5 = instantiate_node(SyntaxNode,input, index...index)
      else
        r5 = nil
      end
      s0 << r5
    end
    if s0.last
      r0 = instantiate_node(HeaderNode,input, i0...index, s0)
      r0.extend(ValidFileHeader1)
      r0.extend(ValidFileHeader2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:valid_file_header][start_index] = r0

    r0
  end

  module InvalidFileHeader0
  end

  module InvalidFileHeader1
    def error
      "invalid file header"
    end
  end

  def _nt_invalid_file_header
    start_index = index
    if node_cache[:invalid_file_header].has_key?(index)
      cached = node_cache[:invalid_file_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('X:', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('X:')
      r2 = nil
    end
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        r4 = _nt_field_line
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(HeaderNode,input, i0...index, s0)
      r0.extend(InvalidFileHeader0)
      r0.extend(InvalidFileHeader1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:invalid_file_header][start_index] = r0

    r0
  end

  module TypesetText0
    def end_of_line
      elements[0]
    end

    def item
      elements[1]
    end
  end

  module TypesetText1
    def first
      elements[0]
    end

    def rest
      elements[1]
    end
  end

  module TypesetText2
    def value
      @value ||= TypesetText.new(item_values.flatten)
    end
  end

  def _nt_typeset_text
    start_index = index
    if node_cache[:typeset_text].has_key?(index)
      cached = node_cache[:typeset_text][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_typeset_text_unit
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_end_of_line
        s3 << r4
        if r4
          r5 = _nt_typeset_text_unit
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(TypesetText0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(TypesetText1)
      r0.extend(TypesetText2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:typeset_text][start_index] = r0

    r0
  end

  module TypesetTextSection0
    def typeset_text
      elements[0]
    end

    def end_of_line
      elements[1]
    end

    def end_of_section
      elements[2]
    end
  end

  def _nt_typeset_text_section
    start_index = index
    if node_cache[:typeset_text_section].has_key?(index)
      cached = node_cache[:typeset_text_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_typeset_text
    s0 << r1
    if r1
      r2 = _nt_end_of_line
      s0 << r2
      if r2
        r3 = _nt_end_of_section
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TypesetTextSection0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:typeset_text_section][start_index] = r0

    r0
  end

  module FreeText0
  end

  module FreeText1
    def text
      elements[1]
    end

    def end_of_line
      elements[2]
    end
  end

  module FreeText2
    def value
      @value ||= FreeText.new(text.text_value)
    end
  end

  def _nt_free_text
    start_index = index
    if node_cache[:free_text].has_key?(index)
      cached = node_cache[:free_text][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_header_start
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        i4, s4 = index, []
        i5 = index
        r6 = _nt_end_of_section
        if r6
          r5 = nil
        else
          @index = i5
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s4 << r5
        if r5
          if index < input_length
            r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("any character")
            r7 = nil
          end
          s4 << r7
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(FreeText0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
      if r3
        r8 = _nt_end_of_line
        s0 << r8
      end
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(FreeText1)
      r0.extend(FreeText2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:free_text][start_index] = r0

    r0
  end

  module HeaderStart0
  end

  def _nt_header_start
    start_index = index
    if node_cache[:header_start].has_key?(index)
      cached = node_cache[:header_start][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_comment_line
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      if has_terminal?('\G[A-Za-z]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      s0 << r3
      if r3
        if has_terminal?(':', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(':')
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(HeaderStart0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:header_start][start_index] = r0

    r0
  end

  def _nt_end_of_file
    start_index = index
    if node_cache[:end_of_file].has_key?(index)
      cached = node_cache[:end_of_file][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if index < input_length
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("any character")
      r1 = nil
    end
    if r1
      r0 = nil
    else
      @index = i0
      r0 = instantiate_node(SyntaxNode,input, index...index)
    end

    node_cache[:end_of_file][start_index] = r0

    r0
  end

  def _nt_line_feed
    start_index = index
    if node_cache[:line_feed].has_key?(index)
      cached = node_cache[:line_feed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?("\r\n", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("\r\n")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("\r", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("\r")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?("\n", false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("\n")
          r3 = nil
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:line_feed][start_index] = r0

    r0
  end

  def _nt_end_of_line
    start_index = index
    if node_cache[:end_of_line].has_key?(index)
      cached = node_cache[:end_of_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_line_feed
    if r1
      r0 = r1
    else
      r2 = _nt_end_of_file
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:end_of_line][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(" ", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(" ")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("\t", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("\t")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:space][start_index] = r0

    r0
  end

  module BlankLine0
    def end_of_line
      elements[1]
    end
  end

  def _nt_blank_line
    start_index = index
    if node_cache[:blank_line].has_key?(index)
      cached = node_cache[:blank_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_space
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r3 = _nt_end_of_line
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BlankLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:blank_line][start_index] = r0

    r0
  end

  module EndOfSection0
    def blank_line
      elements[1]
    end
  end

  module EndOfSection1
    def blank_line
      elements[0]
    end

  end

  def _nt_end_of_section
    start_index = index
    if node_cache[:end_of_section].has_key?(index)
      cached = node_cache[:end_of_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_blank_line
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        i4 = index
        r5 = _nt_end_of_file
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_blank_line
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(EndOfSection0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(EndOfSection1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_of_section][start_index] = r0

    r0
  end

  module Comment0
  end

  module Comment1
  end

  def _nt_comment
    start_index = index
    if node_cache[:comment].has_key?(index)
      cached = node_cache[:comment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_pseudo_comment
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?('%', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('%')
        r3 = nil
      end
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          i5, s5 = index, []
          i6 = index
          r7 = _nt_end_of_line
          if r7
            r6 = nil
          else
            @index = i6
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s5 << r6
          if r6
            if index < input_length
              r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("any character")
              r8 = nil
            end
            s5 << r8
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Comment0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Comment1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:comment][start_index] = r0

    r0
  end

  module CommentLine0
    def comment
      elements[1]
    end

    def end_of_line
      elements[2]
    end
  end

  def _nt_comment_line
    start_index = index
    if node_cache[:comment_line].has_key?(index)
      cached = node_cache[:comment_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    s2, i2 = [], index
    loop do
      r3 = _nt_space
      if r3
        s2 << r3
      else
        break
      end
    end
    r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
    s1 << r2
    if r2
      r4 = _nt_comment
      s1 << r4
      if r4
        r5 = _nt_end_of_line
        s1 << r5
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(CommentLine0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r6 = _nt_remarks_field_line
      if r6
        r0 = r6
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:comment_line][start_index] = r0

    r0
  end

  module LineEnder0
    def end_of_line
      elements[2]
    end

  end

  def _nt_line_ender
    start_index = index
    if node_cache[:line_ender].has_key?(index)
      cached = node_cache[:line_ender][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_space
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r4 = _nt_comment
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_end_of_line
        s0 << r5
        if r5
          s6, i6 = [], index
          loop do
            r7 = _nt_comment_line
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LineEnder0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:line_ender][start_index] = r0

    r0
  end

  module RemarksField0
    def string_field_content
      elements[1]
    end
  end

  def _nt_remarks_field
    start_index = index
    if node_cache[:remarks_field].has_key?(index)
      cached = node_cache[:remarks_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('r:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('r:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_string_field_content
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RemarksField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:remarks_field][start_index] = r0

    r0
  end

  module RemarksFieldLine0
    def remarks_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_remarks_field_line
    start_index = index
    if node_cache[:remarks_field_line].has_key?(index)
      cached = node_cache[:remarks_field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_remarks_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RemarksFieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:remarks_field_line][start_index] = r0

    r0
  end

  module InlineRemarksField0
    def inline_string_field_content
      elements[1]
    end
  end

  def _nt_inline_remarks_field
    start_index = index
    if node_cache[:inline_remarks_field].has_key?(index)
      cached = node_cache[:inline_remarks_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('r:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('r:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_inline_string_field_content
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InlineRemarksField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:inline_remarks_field][start_index] = r0

    r0
  end

  module MusicLineEnder0
  end

  def _nt_music_line_ender
    start_index = index
    if node_cache[:music_line_ender].has_key?(index)
      cached = node_cache[:music_line_ender][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_music_space
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      i3 = index
      r4 = _nt_code_linebreak
      if r4
        r3 = r4
      else
        r5 = _nt_music_line_continuation
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MusicLineEnder0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:music_line_ender][start_index] = r0

    r0
  end

  module CodeLinebreak0
    def line_ender
      elements[1]
    end
  end

  module CodeLinebreak1
    def value
      ABCElement::CODE_LINEBREAK
    end
  end

  def _nt_code_linebreak
    start_index = index
    if node_cache[:code_linebreak].has_key?(index)
      cached = node_cache[:code_linebreak][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 0))
      @index += 0
    else
      terminal_parse_failure('')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(CodeLinebreak0)
      r0.extend(CodeLinebreak1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:code_linebreak][start_index] = r0

    r0
  end

  module MusicLineContinuation0
    def line_ender
      elements[1]
    end
  end

  def _nt_music_line_continuation
    start_index = index
    if node_cache[:music_line_continuation].has_key?(index)
      cached = node_cache[:music_line_continuation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\\', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('\\')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MusicLineContinuation0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:music_line_continuation][start_index] = r0

    r0
  end

  module AbcFragment0
    def partial_tune_header
      elements[0]
    end

  end

  module AbcFragment1
  end

  module AbcFragment2
    def value
      @value ||= Tune.new(values)
    end
  end

  def _nt_abc_fragment
    start_index = index
    if node_cache[:abc_fragment].has_key?(index)
      cached = node_cache[:abc_fragment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 0))
      @index += 0
    else
      terminal_parse_failure('')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3, s3 = index, []
      r4 = _nt_partial_tune_header
      s3 << r4
      if r4
        r6 = _nt_tune_body
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(AbcFragment0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r7 = _nt_tune_body
        if r7
          r2 = r7
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(TuneNode,input, i0...index, s0)
      r0.extend(AbcFragment1)
      r0.extend(AbcFragment2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:abc_fragment][start_index] = r0

    r0
  end

  module PartialTuneHeader0
    def key_field_line
      elements[1]
    end
  end

  module PartialTuneHeader1
  end

  module PartialTuneHeader2
  end

  def _nt_partial_tune_header
    start_index = index
    if node_cache[:partial_tune_header].has_key?(index)
      cached = node_cache[:partial_tune_header][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 0))
      @index += 0
    else
      terminal_parse_failure('')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3, s3 = index, []
      r5 = _nt_refnum_field_line
      if r5
        r4 = r5
      else
        r4 = instantiate_node(SyntaxNode,input, index...index)
      end
      s3 << r4
      if r4
        i6 = index
        i7, s7 = index, []
        s8, i8 = [], index
        loop do
          r9 = _nt_tune_header_line
          if r9
            s8 << r9
          else
            break
          end
        end
        r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
        s7 << r8
        if r8
          r10 = _nt_key_field_line
          s7 << r10
        end
        if s7.last
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          r7.extend(PartialTuneHeader0)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r6 = r7
        else
          s11, i11 = [], index
          loop do
            r12 = _nt_tune_header_line
            if r12
              s11 << r12
            else
              break
            end
          end
          if s11.empty?
            @index = i11
            r11 = nil
          else
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
          end
          if r11
            r6 = r11
          else
            @index = i6
            r6 = nil
          end
        end
        s3 << r6
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(PartialTuneHeader1)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r13 = _nt_refnum_field_line
        if r13
          r2 = r13
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(HeaderNode,input, i0...index, s0)
      r0.extend(PartialTuneHeader2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:partial_tune_header][start_index] = r0

    r0
  end

  def _nt_any_field
    start_index = index
    if node_cache[:any_field].has_key?(index)
      cached = node_cache[:any_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_typeset_text
    if r1
      r0 = r1
    else
      r2 = _nt_special_field
      if r2
        r0 = r2
      else
        r3 = _nt_string_field
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:any_field][start_index] = r0

    r0
  end

  module FieldLine0
    def any_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_field_line
    start_index = index
    if node_cache[:field_line].has_key?(index)
      cached = node_cache[:field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_any_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:field_line][start_index] = r0

    r0
  end

  def _nt_special_field
    start_index = index
    if node_cache[:special_field].has_key?(index)
      cached = node_cache[:special_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_remarks_field
    if r1
      r0 = r1
    else
      r2 = _nt_instruction_field
      if r2
        r0 = r2
      else
        r3 = _nt_key_field
        if r3
          r0 = r3
        else
          r4 = _nt_unit_note_length_field
          if r4
            r0 = r4
          else
            r5 = _nt_meter_field
            if r5
              r0 = r5
            else
              r6 = _nt_macro_field
              if r6
                r0 = r6
              else
                r7 = _nt_tempo_field
                if r7
                  r0 = r7
                else
                  r8 = _nt_symbol_line
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_user_defined_field
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_lyrics_line
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_refnum_field
                        if r11
                          r0 = r11
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:special_field][start_index] = r0

    r0
  end

  module StringField0
    def content
      elements[4]
    end
  end

  def _nt_string_field
    start_index = index
    if node_cache[:string_field].has_key?(index)
      cached = node_cache[:string_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_special_field_identifier
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?('\G[A-Za-z]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      s0 << r3
      if r3
        if has_terminal?(':', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(':')
          r4 = nil
        end
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_field_space
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            r7 = _nt_string_field_content
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(StringField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:string_field][start_index] = r0

    r0
  end

  module StringFieldContent0
  end

  module StringFieldContent1
    def line_ender
      elements[0]
    end

    def content
      elements[2]
    end
  end

  module StringFieldContent2
    def start
      elements[0]
    end

    def extra
      elements[1]
    end
  end

  module StringFieldContent3
    def value
      TextString.new(start.text_value + (extra.empty? ? '' : ' ' + extra.content.value))
    end
  end

  def _nt_string_field_content
    start_index = index
    if node_cache[:string_field_content].has_key?(index)
      cached = node_cache[:string_field_content][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      i3 = index
      r4 = _nt_line_ender
      if r4
        r3 = nil
      else
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s2 << r3
      if r3
        if index < input_length
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("any character")
          r5 = nil
        end
        s2 << r5
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(StringFieldContent0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      i7, s7 = index, []
      r8 = _nt_line_ender
      s7 << r8
      if r8
        if has_terminal?('+:', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('+:')
          r9 = nil
        end
        s7 << r9
        if r9
          r10 = _nt_string_field_content
          s7 << r10
        end
      end
      if s7.last
        r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
        r7.extend(StringFieldContent1)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r6 = r7
      else
        r6 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r6
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(StringFieldContent2)
      r0.extend(StringFieldContent3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:string_field_content][start_index] = r0

    r0
  end

  def _nt_special_field_identifier
    start_index = index
    if node_cache[:special_field_identifier].has_key?(index)
      cached = node_cache[:special_field_identifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[IKLMmPQrsUwX]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:special_field_identifier][start_index] = r0

    r0
  end

  def _nt_file_header_field_excludes
    start_index = index
    if node_cache[:file_header_field_excludes].has_key?(index)
      cached = node_cache[:file_header_field_excludes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[KPQsTVWwX]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:file_header_field_excludes][start_index] = r0

    r0
  end

  def _nt_tune_header_field_excludes
    start_index = index
    if node_cache[:tune_header_field_excludes].has_key?(index)
      cached = node_cache[:tune_header_field_excludes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('\G[swXK]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r2 = _nt_tune_header_instruction_field_excludes
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:tune_header_field_excludes][start_index] = r0

    r0
  end

  def _nt_tune_body_field_excludes
    start_index = index
    if node_cache[:tune_body_field_excludes].has_key?(index)
      cached = node_cache[:tune_body_field_excludes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('\G[A-Ga-gX-Zx-zHOSm]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r2 = _nt_tune_body_instruction_field_excludes
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:tune_body_field_excludes][start_index] = r0

    r0
  end

  module FileHeaderField0
    def any_field
      elements[1]
    end
  end

  def _nt_file_header_field
    start_index = index
    if node_cache[:file_header_field].has_key?(index)
      cached = node_cache[:file_header_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_file_header_field_excludes
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_any_field
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FileHeaderField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:file_header_field][start_index] = r0

    r0
  end

  module TuneHeaderField0
    def any_field
      elements[1]
    end
  end

  def _nt_tune_header_field
    start_index = index
    if node_cache[:tune_header_field].has_key?(index)
      cached = node_cache[:tune_header_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_parts_header_field
    if r1
      r0 = r1
    else
      r2 = _nt_voice_header_field
      if r2
        r0 = r2
      else
        i3, s3 = index, []
        i4 = index
        r5 = _nt_tune_header_field_excludes
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_any_field
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(TuneHeaderField0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:tune_header_field][start_index] = r0

    r0
  end

  module TuneHeaderLine0
    def tune_header_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_tune_header_line
    start_index = index
    if node_cache[:tune_header_line].has_key?(index)
      cached = node_cache[:tune_header_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tune_header_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneHeaderLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_header_line][start_index] = r0

    r0
  end

  module TuneBodyField0
    def any_field
      elements[1]
    end
  end

  def _nt_tune_body_field
    start_index = index
    if node_cache[:tune_body_field].has_key?(index)
      cached = node_cache[:tune_body_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_parts_body_field
    if r1
      r0 = r1
    else
      r2 = _nt_voice_body_field
      if r2
        r0 = r2
      else
        i3, s3 = index, []
        i4 = index
        r5 = _nt_tune_body_field_excludes
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_any_field
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(TuneBodyField0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:tune_body_field][start_index] = r0

    r0
  end

  module TuneBodyFieldLine0
    def tune_body_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_tune_body_field_line
    start_index = index
    if node_cache[:tune_body_field_line].has_key?(index)
      cached = node_cache[:tune_body_field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tune_body_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneBodyFieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_body_field_line][start_index] = r0

    r0
  end

  def _nt_inline_field_excludes
    start_index = index
    if node_cache[:inline_field_excludes].has_key?(index)
      cached = node_cache[:inline_field_excludes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[A-Ga-gX-Zx-zHOSsTWw]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:inline_field_excludes][start_index] = r0

    r0
  end

  def _nt_any_inline_field
    start_index = index
    if node_cache[:any_inline_field].has_key?(index)
      cached = node_cache[:any_inline_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_parts_body_field
    if r1
      r0 = r1
    else
      r2 = _nt_voice_body_field
      if r2
        r0 = r2
      else
        r3 = _nt_inline_special_field
        if r3
          r0 = r3
        else
          r4 = _nt_inline_string_field
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:any_inline_field][start_index] = r0

    r0
  end

  module InlineSpecialField0
    def special_field
      elements[1]
    end
  end

  def _nt_inline_special_field
    start_index = index
    if node_cache[:inline_special_field].has_key?(index)
      cached = node_cache[:inline_special_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_inline_instruction_field
    if r1
      r0 = r1
    else
      r2 = _nt_inline_remarks_field
      if r2
        r0 = r2
      else
        i3, s3 = index, []
        i4 = index
        i5 = index
        if has_terminal?('I', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('I')
          r6 = nil
        end
        if r6
          r5 = r6
        else
          if has_terminal?('%%', false, index)
            r7 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('%%')
            r7 = nil
          end
          if r7
            r5 = r7
          else
            if has_terminal?('r', false, index)
              r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('r')
              r8 = nil
            end
            if r8
              r5 = r8
            else
              @index = i5
              r5 = nil
            end
          end
        end
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r9 = _nt_special_field
          s3 << r9
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(InlineSpecialField0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:inline_special_field][start_index] = r0

    r0
  end

  module InlineStringField0
    def content
      elements[3]
    end
  end

  def _nt_inline_string_field
    start_index = index
    if node_cache[:inline_string_field].has_key?(index)
      cached = node_cache[:inline_string_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_special_field_identifier
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?('\G[A-Za-z]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      s0 << r3
      if r3
        if has_terminal?(':', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(':')
          r4 = nil
        end
        s0 << r4
        if r4
          r5 = _nt_inline_string_field_content
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(InlineStringField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:inline_string_field][start_index] = r0

    r0
  end

  module InlineStringFieldContent0
  end

  module InlineStringFieldContent1
    def value
      TextString.new(text_value)
    end
  end

  def _nt_inline_string_field_content
    start_index = index
    if node_cache[:inline_string_field_content].has_key?(index)
      cached = node_cache[:inline_string_field_content][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1, s1 = index, []
      i2 = index
      i3 = index
      if has_terminal?(']', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(']')
        r4 = nil
      end
      if r4
        r3 = r4
      else
        r5 = _nt_line_ender
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r2
      if r2
        if index < input_length
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("any character")
          r6 = nil
        end
        s1 << r6
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(InlineStringFieldContent0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InlineStringFieldContent1)
    end

    node_cache[:inline_string_field_content][start_index] = r0

    r0
  end

  module InlineField0
    def any_inline_field
      elements[1]
    end
  end

  module InlineField1
  end

  def _nt_inline_field
    start_index = index
    if node_cache[:inline_field].has_key?(index)
      cached = node_cache[:inline_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('[', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[')
      r1 = nil
    end
    s0 << r1
    if r1
      i2, s2 = index, []
      i3 = index
      r4 = _nt_inline_field_excludes
      if r4
        r3 = nil
      else
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s2 << r3
      if r3
        r5 = _nt_any_inline_field
        s2 << r5
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(InlineField0)
      else
        @index = i2
        r2 = nil
      end
      s0 << r2
      if r2
        if has_terminal?(']', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(']')
          r6 = nil
        end
        s0 << r6
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InlineField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:inline_field][start_index] = r0

    r0
  end

  module RefnumField0
    def content
      elements[1]
    end
  end

  module RefnumField1
  end

  def _nt_refnum_field
    start_index = index
    if node_cache[:refnum_field].has_key?(index)
      cached = node_cache[:refnum_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('X:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('X:')
      r1 = nil
    end
    s0 << r1
    if r1
      i3 = index
      r4 = _nt_posint
      if r4
        r3 = r4
      else
        r5 = _nt_invalid_refnum
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(RefnumField0)
      r0.extend(RefnumField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:refnum_field][start_index] = r0

    r0
  end

  module InvalidRefnum0
    def error
      "refnum (X:) field must be a positive integer"
    end
  end

  def _nt_invalid_refnum
    start_index = index
    if node_cache[:invalid_refnum].has_key?(index)
      cached = node_cache[:invalid_refnum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_string_field_content
    r0.extend(InvalidRefnum0)

    node_cache[:invalid_refnum][start_index] = r0

    r0
  end

  module RefnumFieldLine0
    def refnum_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_refnum_field_line
    start_index = index
    if node_cache[:refnum_field_line].has_key?(index)
      cached = node_cache[:refnum_field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_refnum_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RefnumFieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:refnum_field_line][start_index] = r0

    r0
  end

  module TitleField0
    def content
      elements[1]
    end
  end

  def _nt_title_field
    start_index = index
    if node_cache[:title_field].has_key?(index)
      cached = node_cache[:title_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('T:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('T:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_string_field_content
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(TitleField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:title_field][start_index] = r0

    r0
  end

  module TitleFieldLine0
    def title_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_title_field_line
    start_index = index
    if node_cache[:title_field_line].has_key?(index)
      cached = node_cache[:title_field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_title_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TitleFieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:title_field_line][start_index] = r0

    r0
  end

  module MeterField0
    def content
      elements[1]
    end
  end

  def _nt_meter_field
    start_index = index
    if node_cache[:meter_field].has_key?(index)
      cached = node_cache[:meter_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('M:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('M:')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_named_meter
      if r3
        r2 = r3
      else
        r4 = _nt_fractional_meter
        if r4
          r2 = r4
        else
          r5 = _nt_complex_meter
          if r5
            r2 = r5
          else
            @index = i2
            r2 = nil
          end
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(MeterField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:meter_field][start_index] = r0

    r0
  end

  module FractionalMeter0
    def num
      elements[0]
    end

    def denom
      elements[2]
    end
  end

  module FractionalMeter1
    def value
      @value ||= Meter.new(num.value, denom.value)
    end
  end

  def _nt_fractional_meter
    start_index = index
    if node_cache[:fractional_meter].has_key?(index)
      cached = node_cache[:fractional_meter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_posint
    s0 << r1
    if r1
      if has_terminal?("/", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("/")
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_posint
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FractionalMeter0)
      r0.extend(FractionalMeter1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:fractional_meter][start_index] = r0

    r0
  end

  module NamedMeter0
    def value
      @value ||= Meter.new({ "C|" => :cut, "C" => :common, "none" => :free }[text_value])
    end
  end

  def _nt_named_meter
    start_index = index
    if node_cache[:named_meter].has_key?(index)
      cached = node_cache[:named_meter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?("C|", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("C|")
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(NamedMeter0)
    else
      if has_terminal?("C", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("C")
        r2 = nil
      end
      if r2
        r0 = r2
        r0.extend(NamedMeter0)
      else
        if has_terminal?("none", false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure("none")
          r3 = nil
        end
        if r3
          r0 = r3
          r0.extend(NamedMeter0)
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:named_meter][start_index] = r0

    r0
  end

  module ComplexMeter0
    def num
      elements[0]
    end

    def denom
      elements[2]
    end
  end

  module ComplexMeter1
    def value
      @value ||= Meter.new(num.addends, denom.value)
    end
  end

  def _nt_complex_meter
    start_index = index
    if node_cache[:complex_meter].has_key?(index)
      cached = node_cache[:complex_meter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sum_maybe_parenthesized
    s0 << r1
    if r1
      if has_terminal?('/', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('/')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_posint
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ComplexMeter0)
      r0.extend(ComplexMeter1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:complex_meter][start_index] = r0

    r0
  end

  module SumMaybeParenthesized0
    def s
      elements[1]
    end

  end

  module SumMaybeParenthesized1

    def addends
      s.addends
    end
  end

  def _nt_sum_maybe_parenthesized
    start_index = index
    if node_cache[:sum_maybe_parenthesized].has_key?(index)
      cached = node_cache[:sum_maybe_parenthesized][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('(', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r2 = nil
    end
    s1 << r2
    if r2
      r3 = _nt_sum
      s1 << r3
      if r3
        if has_terminal?(')', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(')')
          r4 = nil
        end
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(SumMaybeParenthesized0)
      r1.extend(SumMaybeParenthesized1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt_sum
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sum_maybe_parenthesized][start_index] = r0

    r0
  end

  module Sum0
    def number
      elements[1]
    end
  end

  module Sum1
    def first
      elements[0]
    end

    def rest
      elements[1]
    end
  end

  module Sum2
    def addends
      @addends ||= rest.elements.inject([first.value]) do |list, el| 
        list << el.number.value
      end
    end
  end

  def _nt_sum
    start_index = index
    if node_cache[:sum].has_key?(index)
      cached = node_cache[:sum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_posint
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        if has_terminal?('+', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('+')
          r4 = nil
        end
        s3 << r4
        if r4
          r5 = _nt_posint
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Sum0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Sum1)
      r0.extend(Sum2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sum][start_index] = r0

    r0
  end

  module UnitNoteLengthField0
    def content
      elements[1]
    end
  end

  def _nt_unit_note_length_field
    start_index = index
    if node_cache[:unit_note_length_field].has_key?(index)
      cached = node_cache[:unit_note_length_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('L:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('L:')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_rational
      if r3
        r2 = r3
      else
        r4 = _nt_posint
        if r4
          r2 = r4
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(UnitNoteLengthField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:unit_note_length_field][start_index] = r0

    r0
  end

  module TempoField0
    def content
      elements[1]
    end
  end

  def _nt_tempo_field
    start_index = index
    if node_cache[:tempo_field].has_key?(index)
      cached = node_cache[:tempo_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('Q:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('Q:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_tempo_field_content
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(TempoField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tempo_field][start_index] = r0

    r0
  end

  def _nt_tempo_field_content
    start_index = index
    if node_cache[:tempo_field_content].has_key?(index)
      cached = node_cache[:tempo_field_content][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_tempo_with_leading_label
    if r1
      r0 = r1
    else
      r2 = _nt_tempo_with_trailing_label
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:tempo_field_content][start_index] = r0

    r0
  end

  module TempoWithLeadingLabel0
    def label
      elements[0]
    end

    def specifier
      elements[2]
    end
  end

  module TempoWithLeadingLabel1
    def value
      if specifier.empty?
        Tempo.new(:label => label.value)
      else
        (tempo = specifier.value).label = label.value; tempo
      end
    end
  end

  def _nt_tempo_with_leading_label
    start_index = index
    if node_cache[:tempo_with_leading_label].has_key?(index)
      cached = node_cache[:tempo_with_leading_label][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_quoted_string
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r5 = _nt_tempo_specifier
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TempoWithLeadingLabel0)
      r0.extend(TempoWithLeadingLabel1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tempo_with_leading_label][start_index] = r0

    r0
  end

  module TempoWithTrailingLabel0
    def tempo_specifier
      elements[0]
    end

    def label
      elements[2]
    end
  end

  module TempoWithTrailingLabel1
    def value
      tempo = tempo_specifier.value
      tempo.label = label.value if !label.empty?
      tempo
    end
  end

  def _nt_tempo_with_trailing_label
    start_index = index
    if node_cache[:tempo_with_trailing_label].has_key?(index)
      cached = node_cache[:tempo_with_trailing_label][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tempo_specifier
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r5 = _nt_quoted_string
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TempoWithTrailingLabel0)
      r0.extend(TempoWithTrailingLabel1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tempo_with_trailing_label][start_index] = r0

    r0
  end

  module TempoLabelOnly0
    def value
      Tempo.new(:label => value)
    end
  end

  def _nt_tempo_label_only
    start_index = index
    if node_cache[:tempo_label_only].has_key?(index)
      cached = node_cache[:tempo_label_only][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_quoted_string
    r0.extend(TempoLabelOnly0)

    node_cache[:tempo_label_only][start_index] = r0

    r0
  end

  module TempoSpecifier0
    def beats
      elements[0]
    end

    def bpm
      elements[1]
    end
  end

  module TempoSpecifier1
    def value
      Tempo.new(:beat_parts => (beats.empty? ? nil : beats.value), :bpm => bpm.value)
    end
  end

  def _nt_tempo_specifier
    start_index = index
    if node_cache[:tempo_specifier].has_key?(index)
      cached = node_cache[:tempo_specifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_beat_parts
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_posint
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TempoSpecifier0)
      r0.extend(TempoSpecifier1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tempo_specifier][start_index] = r0

    r0
  end

  module BeatParts0
    def beats
      elements[0]
    end

  end

  module BeatParts1
    def value
      beats.text_value == 'C' ? [ Rational(1, 4) ] : beats.value
    end
  end

  def _nt_beat_parts
    start_index = index
    if node_cache[:beat_parts].has_key?(index)
      cached = node_cache[:beat_parts][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_rationals
    if r2
      r1 = r2
    else
      if has_terminal?('C', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('C')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r4 = nil
      end
      s0 << r4
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BeatParts0)
      r0.extend(BeatParts1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:beat_parts][start_index] = r0

    r0
  end

  module PartsHeaderField0
    def content
      elements[1]
    end
  end

  def _nt_parts_header_field
    start_index = index
    if node_cache[:parts_header_field].has_key?(index)
      cached = node_cache[:parts_header_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('P:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('P:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_parts
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(PartsHeaderField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parts_header_field][start_index] = r0

    r0
  end

  module Parts0
    def item
      elements[0]
    end

  end

  module Parts1
    def items
      elements[1]
    end
  end

  module Parts2
    def value
      @value ||= 
        PartSequence.new(items.elements.inject([]) { |list, el| list << el.item.value })
    end
  end

  def _nt_parts
    start_index = index
    if node_cache[:parts].has_key?(index)
      cached = node_cache[:parts][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_dots
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        i4, s4 = index, []
        i5 = index
        r6 = _nt_parts_atom
        if r6
          r5 = r6
        else
          r7 = _nt_parts_group
          if r7
            r5 = r7
          else
            @index = i5
            r5 = nil
          end
        end
        s4 << r5
        if r5
          r9 = _nt_dots
          if r9
            r8 = r9
          else
            r8 = instantiate_node(SyntaxNode,input, index...index)
          end
          s4 << r8
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(Parts0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Parts1)
      r0.extend(Parts2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parts][start_index] = r0

    r0
  end

  module PartsAtom0
    def part
      elements[0]
    end

    def repeat_node
      elements[2]
    end
  end

  module PartsAtom1
    def value
      @value ||= PartsAtom.new(part.text_value, repeat_node.value || 1)
    end
  end

  def _nt_parts_atom
    start_index = index
    if node_cache[:parts_atom].has_key?(index)
      cached = node_cache[:parts_atom][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[A-Z]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      r3 = _nt_dots
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r5 = _nt_posint
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PartsAtom0)
      r0.extend(PartsAtom1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parts_atom][start_index] = r0

    r0
  end

  module PartsGroup0
    def parts
      elements[1]
    end

    def repeat_node
      elements[4]
    end
  end

  module PartsGroup1
    def value
      @value ||= PartsGroup.new(parts.value, repeat_node.value || 1)
    end
  end

  def _nt_parts_group
    start_index = index
    if node_cache[:parts_group].has_key?(index)
      cached = node_cache[:parts_group][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_parts
      s0 << r2
      if r2
        if has_terminal?(')', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(')')
          r3 = nil
        end
        s0 << r3
        if r3
          r5 = _nt_dots
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
          if r4
            r7 = _nt_posint
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PartsGroup0)
      r0.extend(PartsGroup1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parts_group][start_index] = r0

    r0
  end

  module PartsBodyField0
    def content
      elements[1]
    end
  end

  module PartsBodyField1
    def type
      :part_marker
    end
  end

  def _nt_parts_body_field
    start_index = index
    if node_cache[:parts_body_field].has_key?(index)
      cached = node_cache[:parts_body_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('P:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('P:')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('\G[A-Za-z]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(PartsBodyField0)
      r0.extend(PartsBodyField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parts_body_field][start_index] = r0

    r0
  end

  def _nt_dots
    start_index = index
    if node_cache[:dots].has_key?(index)
      cached = node_cache[:dots][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('.', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('.')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:dots][start_index] = r0

    r0
  end

  module KeyField0
    def content
      elements[1]
    end
  end

  module KeyField1
    def content_value
      content.text_value == "none" ? Key::NONE : content.value
    end
  end

  def _nt_key_field
    start_index = index
    if node_cache[:key_field].has_key?(index)
      cached = node_cache[:key_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('K:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('K:')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_key
      if r3
        r2 = r3
      else
        if has_terminal?("none", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure("none")
          r4 = nil
        end
        if r4
          r2 = r4
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(KeyField0)
      r0.extend(KeyField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:key_field][start_index] = r0

    r0
  end

  module KeyFieldLine0
    def key_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_key_field_line
    start_index = index
    if node_cache[:key_field_line].has_key?(index)
      cached = node_cache[:key_field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_key_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(KeyFieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:key_field_line][start_index] = r0

    r0
  end

  module Key0
    def tonic
      elements[0]
    end

    def mode
      elements[2]
    end

    def extra
      elements[4]
    end

    def clef
      elements[6]
    end
  end

  module Key1

    def value
      if !@key
        accidentals = extra.elements.inject({}) do |result, acc| 
          result.merge!(acc.note_letter => acc.accidental.value)
        end
        @key = Key.new(tonic.text_value, mode.text_value, accidentals)
        @key.clef = clef.value unless clef.empty?
      end
      @key
    end
  end

  def _nt_key
    start_index = index
    if node_cache[:key].has_key?(index)
      cached = node_cache[:key][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_tonic
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        r4 = _nt_space
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s0 << r3
      if r3
        r6 = _nt_mode
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r5
        if r5
          s7, i7 = [], index
          loop do
            r8 = _nt_space
            if r8
              s7 << r8
            else
              break
            end
          end
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          s0 << r7
          if r7
            s9, i9 = [], index
            loop do
              r10 = _nt_key_accidental
              if r10
                s9 << r10
              else
                break
              end
            end
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            s0 << r9
            if r9
              s11, i11 = [], index
              loop do
                r12 = _nt_space
                if r12
                  s11 << r12
                else
                  break
                end
              end
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              s0 << r11
              if r11
                r14 = _nt_clef
                if r14
                  r13 = r14
                else
                  r13 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r13
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Key0)
      r0.extend(Key1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:key][start_index] = r0

    r0
  end

  module Tonic0
  end

  def _nt_tonic
    start_index = index
    if node_cache[:tonic].has_key?(index)
      cached = node_cache[:tonic][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('\G[A-G]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    s1 << r2
    if r2
      i4 = index
      if has_terminal?('#', false, index)
        r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('#')
        r5 = nil
      end
      if r5
        r4 = r5
      else
        if has_terminal?('b', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('b')
          r6 = nil
        end
        if r6
          r4 = r6
        else
          @index = i4
          r4 = nil
        end
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Tonic0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('HP', false, index)
        r7 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('HP')
        r7 = nil
      end
      if r7
        r0 = r7
      else
        if has_terminal?('Hp', false, index)
          r8 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('Hp')
          r8 = nil
        end
        if r8
          r0 = r8
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:tonic][start_index] = r0

    r0
  end

  module Mode0
  end

  module Mode1
  end

  module Mode2
  end

  module Mode3
  end

  module Mode4
  end

  module Mode5
  end

  module Mode6
  end

  module Mode7
  end

  module Mode8
  end

  module Mode9
  end

  module Mode10
  end

  def _nt_mode
    start_index = index
    if node_cache[:mode].has_key?(index)
      cached = node_cache[:mode][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    i2 = index
    i3, s3 = index, []
    if has_terminal?('\G[mM]', true, index)
      r4 = true
      @index += 1
    else
      r4 = nil
    end
    s3 << r4
    if r4
      if has_terminal?('\G[aA]', true, index)
        r5 = true
        @index += 1
      else
        r5 = nil
      end
      s3 << r5
      if r5
        if has_terminal?('\G[jJ]', true, index)
          r6 = true
          @index += 1
        else
          r6 = nil
        end
        s3 << r6
      end
    end
    if s3.last
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      r3.extend(Mode0)
    else
      @index = i3
      r3 = nil
    end
    if r3
      r2 = r3
    else
      i7, s7 = index, []
      if has_terminal?('\G[mM]', true, index)
        r8 = true
        @index += 1
      else
        r8 = nil
      end
      s7 << r8
      if r8
        if has_terminal?('\G[iI]', true, index)
          r9 = true
          @index += 1
        else
          r9 = nil
        end
        s7 << r9
        if r9
          if has_terminal?('\G[nN]', true, index)
            r10 = true
            @index += 1
          else
            r10 = nil
          end
          s7 << r10
        end
      end
      if s7.last
        r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
        r7.extend(Mode1)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r2 = r7
      else
        i11, s11 = index, []
        if has_terminal?('\G[iI]', true, index)
          r12 = true
          @index += 1
        else
          r12 = nil
        end
        s11 << r12
        if r12
          if has_terminal?('\G[oO]', true, index)
            r13 = true
            @index += 1
          else
            r13 = nil
          end
          s11 << r13
          if r13
            if has_terminal?('\G[nN]', true, index)
              r14 = true
              @index += 1
            else
              r14 = nil
            end
            s11 << r14
          end
        end
        if s11.last
          r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
          r11.extend(Mode2)
        else
          @index = i11
          r11 = nil
        end
        if r11
          r2 = r11
        else
          i15, s15 = index, []
          if has_terminal?('\G[aA]', true, index)
            r16 = true
            @index += 1
          else
            r16 = nil
          end
          s15 << r16
          if r16
            if has_terminal?('\G[eE]', true, index)
              r17 = true
              @index += 1
            else
              r17 = nil
            end
            s15 << r17
            if r17
              if has_terminal?('\G[oO]', true, index)
                r18 = true
                @index += 1
              else
                r18 = nil
              end
              s15 << r18
            end
          end
          if s15.last
            r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
            r15.extend(Mode3)
          else
            @index = i15
            r15 = nil
          end
          if r15
            r2 = r15
          else
            i19, s19 = index, []
            if has_terminal?('\G[mM]', true, index)
              r20 = true
              @index += 1
            else
              r20 = nil
            end
            s19 << r20
            if r20
              if has_terminal?('\G[iI]', true, index)
                r21 = true
                @index += 1
              else
                r21 = nil
              end
              s19 << r21
              if r21
                if has_terminal?('\G[xX]', true, index)
                  r22 = true
                  @index += 1
                else
                  r22 = nil
                end
                s19 << r22
              end
            end
            if s19.last
              r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
              r19.extend(Mode4)
            else
              @index = i19
              r19 = nil
            end
            if r19
              r2 = r19
            else
              i23, s23 = index, []
              if has_terminal?('\G[dD]', true, index)
                r24 = true
                @index += 1
              else
                r24 = nil
              end
              s23 << r24
              if r24
                if has_terminal?('\G[oO]', true, index)
                  r25 = true
                  @index += 1
                else
                  r25 = nil
                end
                s23 << r25
                if r25
                  if has_terminal?('\G[rR]', true, index)
                    r26 = true
                    @index += 1
                  else
                    r26 = nil
                  end
                  s23 << r26
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(Mode5)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r2 = r23
              else
                i27, s27 = index, []
                if has_terminal?('\G[pP]', true, index)
                  r28 = true
                  @index += 1
                else
                  r28 = nil
                end
                s27 << r28
                if r28
                  if has_terminal?('\G[hH]', true, index)
                    r29 = true
                    @index += 1
                  else
                    r29 = nil
                  end
                  s27 << r29
                  if r29
                    if has_terminal?('\G[rR]', true, index)
                      r30 = true
                      @index += 1
                    else
                      r30 = nil
                    end
                    s27 << r30
                  end
                end
                if s27.last
                  r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                  r27.extend(Mode6)
                else
                  @index = i27
                  r27 = nil
                end
                if r27
                  r2 = r27
                else
                  i31, s31 = index, []
                  if has_terminal?('\G[lL]', true, index)
                    r32 = true
                    @index += 1
                  else
                    r32 = nil
                  end
                  s31 << r32
                  if r32
                    if has_terminal?('\G[yY]', true, index)
                      r33 = true
                      @index += 1
                    else
                      r33 = nil
                    end
                    s31 << r33
                    if r33
                      if has_terminal?('\G[dD]', true, index)
                        r34 = true
                        @index += 1
                      else
                        r34 = nil
                      end
                      s31 << r34
                    end
                  end
                  if s31.last
                    r31 = instantiate_node(SyntaxNode,input, i31...index, s31)
                    r31.extend(Mode7)
                  else
                    @index = i31
                    r31 = nil
                  end
                  if r31
                    r2 = r31
                  else
                    i35, s35 = index, []
                    if has_terminal?('\G[lL]', true, index)
                      r36 = true
                      @index += 1
                    else
                      r36 = nil
                    end
                    s35 << r36
                    if r36
                      if has_terminal?('\G[oO]', true, index)
                        r37 = true
                        @index += 1
                      else
                        r37 = nil
                      end
                      s35 << r37
                      if r37
                        if has_terminal?('\G[cC]', true, index)
                          r38 = true
                          @index += 1
                        else
                          r38 = nil
                        end
                        s35 << r38
                      end
                    end
                    if s35.last
                      r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                      r35.extend(Mode8)
                    else
                      @index = i35
                      r35 = nil
                    end
                    if r35
                      r2 = r35
                    else
                      @index = i2
                      r2 = nil
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    s1 << r2
    if r2
      s39, i39 = [], index
      loop do
        if has_terminal?('\G[A-Za-z]', true, index)
          r40 = true
          @index += 1
        else
          r40 = nil
        end
        if r40
          s39 << r40
        else
          break
        end
      end
      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
      s1 << r39
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Mode9)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i41, s41 = index, []
      if has_terminal?('m', false, index)
        r42 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('m')
        r42 = nil
      end
      s41 << r42
      if r42
        i43 = index
        if has_terminal?('\G[A-Za-z]', true, index)
          r44 = true
          @index += 1
        else
          r44 = nil
        end
        if r44
          r43 = nil
        else
          @index = i43
          r43 = instantiate_node(SyntaxNode,input, index...index)
        end
        s41 << r43
      end
      if s41.last
        r41 = instantiate_node(SyntaxNode,input, i41...index, s41)
        r41.extend(Mode10)
      else
        @index = i41
        r41 = nil
      end
      if r41
        r0 = r41
      else
        if has_terminal?('exp', false, index)
          r45 = instantiate_node(SyntaxNode,input, index...(index + 3))
          @index += 3
        else
          terminal_parse_failure('exp')
          r45 = nil
        end
        if r45
          r0 = r45
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:mode][start_index] = r0

    r0
  end

  module KeyAccidental0
    def accidental
      elements[0]
    end

    def note_letter
      elements[1]
    end

  end

  module KeyAccidental1
    def note_letter
      super.text_value.upcase
    end
  end

  def _nt_key_accidental
    start_index = index
    if node_cache[:key_accidental].has_key?(index)
      cached = node_cache[:key_accidental][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_accidental
    s0 << r1
    if r1
      r2 = _nt_note_letter
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_space
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(KeyAccidental0)
      r0.extend(KeyAccidental1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:key_accidental][start_index] = r0

    r0
  end

  def _nt_instruction_field
    start_index = index
    if node_cache[:instruction_field].has_key?(index)
      cached = node_cache[:instruction_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_special_instruction_field
    if r1
      r0 = r1
    else
      r2 = _nt_general_instruction_field
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:instruction_field][start_index] = r0

    r0
  end

  def _nt_special_instruction_field
    start_index = index
    if node_cache[:special_instruction_field].has_key?(index)
      cached = node_cache[:special_instruction_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_staves_field
    if r1
      r0 = r1
    else
      r2 = _nt_midi_field
      if r2
        r0 = r2
      else
        r3 = _nt_formatting_field
        if r3
          r0 = r3
        else
          r4 = _nt_writefields_field
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:special_instruction_field][start_index] = r0

    r0
  end

  module GeneralInstructionField0
    def instruction_field_identifier
      elements[0]
    end

    def directive
      elements[1]
    end

    def content
      elements[2]
    end
  end

  module GeneralInstructionField1
    def value
      @value ||= InstructionField.new(text_value[0], directive.text_value, content.value || '')
    end
    def inclusion # handles abc-include
      value.inclusion
    end
  end

  def _nt_general_instruction_field
    start_index = index
    if node_cache[:general_instruction_field].has_key?(index)
      cached = node_cache[:general_instruction_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      r2 = _nt_directive
      s0 << r2
      if r2
        r4 = _nt_instruction_content
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(GeneralInstructionField0)
      r0.extend(GeneralInstructionField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:general_instruction_field][start_index] = r0

    r0
  end

  def _nt_instruction_field_identifier
    start_index = index
    if node_cache[:instruction_field_identifier].has_key?(index)
      cached = node_cache[:instruction_field_identifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('I:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('I:')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('%%', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('%%')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:instruction_field_identifier][start_index] = r0

    r0
  end

  module Directive0
    def directive_chars
      elements[1]
    end
  end

  def _nt_directive
    start_index = index
    if node_cache[:directive].has_key?(index)
      cached = node_cache[:directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_special_directive
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_directive_chars
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Directive0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:directive][start_index] = r0

    r0
  end

  def _nt_directive_chars
    start_index = index
    if node_cache[:directive_chars].has_key?(index)
      cached = node_cache[:directive_chars][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[A-Za-z0-9\\-_:]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:directive_chars][start_index] = r0

    r0
  end

  module SpecialDirective0
  end

  def _nt_special_directive
    start_index = index
    if node_cache[:special_directive].has_key?(index)
      cached = node_cache[:special_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('score', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('score')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('staves', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 6))
        @index += 6
      else
        terminal_parse_failure('staves')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        if has_terminal?('MIDI', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure('MIDI')
          r4 = nil
        end
        if r4
          r1 = r4
        else
          r5 = _nt_formatting_predicate
          if r5
            r1 = r5
          else
            @index = i1
            r1 = nil
          end
        end
      end
    end
    s0 << r1
    if r1
      i6 = index
      r7 = _nt_directive_chars
      if r7
        r6 = nil
      else
        @index = i6
        r6 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r6
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SpecialDirective0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:special_directive][start_index] = r0

    r0
  end

  module InstructionContent0
    def text
      elements[1]
    end
  end

  module InstructionContent1
    def value
      text.value
    end
  end

  def _nt_instruction_content
    start_index = index
    if node_cache[:instruction_content].has_key?(index)
      cached = node_cache[:instruction_content][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_field_space
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r3 = _nt_string_field_content
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InstructionContent0)
      r0.extend(InstructionContent1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:instruction_content][start_index] = r0

    r0
  end

  def _nt_inline_instruction_field
    start_index = index
    if node_cache[:inline_instruction_field].has_key?(index)
      cached = node_cache[:inline_instruction_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_special_instruction_field
    if r1
      r0 = r1
    else
      r2 = _nt_general_inline_instruction_field
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:inline_instruction_field][start_index] = r0

    r0
  end

  module GeneralInlineInstructionField0
    def instruction_field_identifier
      elements[1]
    end

    def directive
      elements[2]
    end

    def content
      elements[3]
    end
  end

  module GeneralInlineInstructionField1
    def value
      @value ||= InstructionField.new(text_value[0], directive.text_value, content.value)
    end
  end

  def _nt_general_inline_instruction_field
    start_index = index
    if node_cache[:general_inline_instruction_field].has_key?(index)
      cached = node_cache[:general_inline_instruction_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_tune_body_instruction_field_excludes
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_instruction_field_identifier
      s0 << r3
      if r3
        r4 = _nt_directive
        s0 << r4
        if r4
          r6 = _nt_inline_instruction_content
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(GeneralInlineInstructionField0)
      r0.extend(GeneralInlineInstructionField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:general_inline_instruction_field][start_index] = r0

    r0
  end

  module InlineInstructionContent0
    def text
      elements[1]
    end
  end

  module InlineInstructionContent1
    def value
      text.text_value
    end
  end

  def _nt_inline_instruction_content
    start_index = index
    if node_cache[:inline_instruction_content].has_key?(index)
      cached = node_cache[:inline_instruction_content][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_space
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r3 = _nt_inline_string_field_content
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(InlineInstructionContent0)
      r0.extend(InlineInstructionContent1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:inline_instruction_content][start_index] = r0

    r0
  end

  module TuneHeaderInstructionFieldExcludes0
    def instruction_field_identifier
      elements[0]
    end

  end

  def _nt_tune_header_instruction_field_excludes
    start_index = index
    if node_cache[:tune_header_instruction_field_excludes].has_key?(index)
      cached = node_cache[:tune_header_instruction_field_excludes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      if has_terminal?('abc-charset', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('abc-charset')
        r2 = nil
      end
      s0 << r2
      if r2
        i3 = index
        r4 = _nt_directive_chars
        if r4
          r3 = nil
        else
          @index = i3
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneHeaderInstructionFieldExcludes0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_header_instruction_field_excludes][start_index] = r0

    r0
  end

  module TuneBodyInstructionFieldExcludes0
    def instruction_field_identifier
      elements[0]
    end

  end

  def _nt_tune_body_instruction_field_excludes
    start_index = index
    if node_cache[:tune_body_instruction_field_excludes].has_key?(index)
      cached = node_cache[:tune_body_instruction_field_excludes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      i2 = index
      if has_terminal?('abc-charset', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('abc-charset')
        r3 = nil
      end
      if r3
        r2 = r3
      else
        if has_terminal?('abc-include', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 11))
          @index += 11
        else
          terminal_parse_failure('abc-include')
          r4 = nil
        end
        if r4
          r2 = r4
        else
          if has_terminal?('abc-version', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 11))
            @index += 11
          else
            terminal_parse_failure('abc-version')
            r5 = nil
          end
          if r5
            r2 = r5
          else
            if has_terminal?('linebreak', false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 9))
              @index += 9
            else
              terminal_parse_failure('linebreak')
              r6 = nil
            end
            if r6
              r2 = r6
            else
              @index = i2
              r2 = nil
            end
          end
        end
      end
      s0 << r2
      if r2
        i7 = index
        r8 = _nt_directive_chars
        if r8
          r7 = nil
        else
          @index = i7
          r7 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneBodyInstructionFieldExcludes0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_body_instruction_field_excludes][start_index] = r0

    r0
  end

  module FieldSpace0
    def line_ender
      elements[0]
    end

  end

  def _nt_field_space
    start_index = index
    if node_cache[:field_space].has_key?(index)
      cached = node_cache[:field_space][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_space
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_line_ender
      s2 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_pseudo_comment_line
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s2 << r4
        if r4
          if has_terminal?('+:', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('+:')
            r6 = nil
          end
          s2 << r6
        end
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(FieldSpace0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:field_space][start_index] = r0

    r0
  end

  module PseudoCommentLine0
    def pseudo_comment
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_pseudo_comment_line
    start_index = index
    if node_cache[:pseudo_comment_line].has_key?(index)
      cached = node_cache[:pseudo_comment_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_pseudo_comment
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PseudoCommentLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pseudo_comment_line][start_index] = r0

    r0
  end

  module Pitch0
    def accidental
      elements[0]
    end

    def note_letter
      elements[1]
    end

    def octave_shift
      elements[2]
    end
  end

  module Pitch1
    def value
      @value ||= Pitch.new(note_letter.text_value.upcase, 
                           :octave => note_letter.octave + octave_shift.value, 
                           :accidental => accidental.value)
    end
  end

  def _nt_pitch
    start_index = index
    if node_cache[:pitch].has_key?(index)
      cached = node_cache[:pitch][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_accidental
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_note_letter
      s0 << r3
      if r3
        r4 = _nt_octave_shift
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Pitch0)
      r0.extend(Pitch1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pitch][start_index] = r0

    r0
  end

  module NoteLetter0
    def octave
      text_value =~ /[a-g]/ ? 1 : 0
    end
  end

  def _nt_note_letter
    start_index = index
    if node_cache[:note_letter].has_key?(index)
      cached = node_cache[:note_letter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[A-Ga-g]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(NoteLetter0)
      @index += 1
    else
      r0 = nil
    end

    node_cache[:note_letter][start_index] = r0

    r0
  end

  module OctaveShift0
    def value
      text_value.count("'") - text_value.count(",")
    end
  end

  def _nt_octave_shift
    start_index = index
    if node_cache[:octave_shift].has_key?(index)
      cached = node_cache[:octave_shift][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      if has_terminal?("'", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("'")
        r2 = nil
      end
      if r2
        r1 = r2
      else
        if has_terminal?(",", false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(",")
          r3 = nil
        end
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(OctaveShift0)

    node_cache[:octave_shift][start_index] = r0

    r0
  end

  module Accidental0
  end

  module Accidental1
    def value
      { "^^" => 2, "^" => 1, "=" => 0, "_" => -1, "__" => -2 }[text_value]
    end
  end

  def _nt_accidental
    start_index = index
    if node_cache[:accidental].has_key?(index)
      cached = node_cache[:accidental][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?("^^", false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("^^")
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?("^", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("^")
        r3 = nil
      end
      if r3
        r1 = r3
      else
        if has_terminal?("__", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("__")
          r4 = nil
        end
        if r4
          r1 = r4
        else
          if has_terminal?("_", false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("_")
            r5 = nil
          end
          if r5
            r1 = r5
          else
            if has_terminal?("=", false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("=")
              r6 = nil
            end
            if r6
              r1 = r6
            else
              @index = i1
              r1 = nil
            end
          end
        end
      end
    end
    s0 << r1
    if r1
      if has_terminal?('', false, index)
        r7 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure('')
        r7 = nil
      end
      s0 << r7
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Accidental0)
      r0.extend(Accidental1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:accidental][start_index] = r0

    r0
  end

  module NoteLength0
    def num
      elements[0]
    end

    def den
      elements[1]
    end
  end

  module NoteLength1
    def value        
      Rational( (num.empty? ? 1 : num.value), (den.empty? ? 1 : den.value) )
    end
  end

  def _nt_note_length
    start_index = index
    if node_cache[:note_length].has_key?(index)
      cached = node_cache[:note_length][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_posint
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      i4 = index
      r5 = _nt_number_denominator
      if r5
        r4 = r5
      else
        r6 = _nt_slashes
        if r6
          r4 = r6
        else
          @index = i4
          r4 = nil
        end
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(NoteLength0)
      r0.extend(NoteLength1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:note_length][start_index] = r0

    r0
  end

  module NumberDenominator0
    def posint
      elements[1]
    end
  end

  module NumberDenominator1
    def value
      posint.value
    end
  end

  def _nt_number_denominator
    start_index = index
    if node_cache[:number_denominator].has_key?(index)
      cached = node_cache[:number_denominator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('/', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('/')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_posint
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(NumberDenominator0)
      r0.extend(NumberDenominator1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:number_denominator][start_index] = r0

    r0
  end

  module Slashes0
    def value
      2 ** text_value.length
    end
  end

  def _nt_slashes
    start_index = index
    if node_cache[:slashes].has_key?(index)
      cached = node_cache[:slashes][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('/', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('/')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Slashes0)
    end

    node_cache[:slashes][start_index] = r0

    r0
  end

  module BrokenRhythm0
    def value
      @value ||= BrokenRhythm.new(text_value)
    end
  end

  def _nt_broken_rhythm
    start_index = index
    if node_cache[:broken_rhythm].has_key?(index)
      cached = node_cache[:broken_rhythm][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    s1, i1 = [], index
    loop do
      if has_terminal?('>', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('>')
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    if r1
      r0 = r1
      r0.extend(BrokenRhythm0)
    else
      s3, i3 = [], index
      loop do
        if has_terminal?('<', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('<')
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      if r3
        r0 = r3
        r0.extend(BrokenRhythm0)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:broken_rhythm][start_index] = r0

    r0
  end

  def _nt_rest
    start_index = index
    if node_cache[:rest].has_key?(index)
      cached = node_cache[:rest][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_note_rest
    if r1
      r0 = r1
    else
      r2 = _nt_measure_rest
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rest][start_index] = r0

    r0
  end

  module NoteRest0
    def note_length
      elements[1]
    end
  end

  module NoteRest1
    def value
      @value ||= Rest.new(note_length.value, :invisible => text_value[0] == 'x')
    end
  end

  def _nt_note_rest
    start_index = index
    if node_cache[:note_rest].has_key?(index)
      cached = node_cache[:note_rest][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[xz]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_note_length
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(NoteRest0)
      r0.extend(NoteRest1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:note_rest][start_index] = r0

    r0
  end

  module MeasureRest0
    def measure_count
      elements[1]
    end
  end

  module MeasureRest1
    attr_accessor :measure_length
    def value
      @value ||= MeasureRest.new(measure_count, :invisible => text_value[0] == 'X')
    end
    def measure_count
      super.empty? ? 1 : super.value
    end
  end

  def _nt_measure_rest
    start_index = index
    if node_cache[:measure_rest].has_key?(index)
      cached = node_cache[:measure_rest][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[XZ]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      r3 = _nt_posint
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(MeasureRest0)
      r0.extend(MeasureRest1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:measure_rest][start_index] = r0

    r0
  end

  module ClefTranspose0
    def transpose
      elements[2]
    end
  end

  module ClefTranspose1
    def set_clef_opts(opts)
      opts.merge!(:transpose => transpose.value)
    end
  end

  def _nt_clef_transpose
    start_index = index
    if node_cache[:clef_transpose].has_key?(index)
      cached = node_cache[:clef_transpose][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('transpose', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure('transpose')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('t', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('t')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r4 = nil
      end
      s0 << r4
      if r4
        r5 = _nt_integer
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClefTranspose0)
      r0.extend(ClefTranspose1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef_transpose][start_index] = r0

    r0
  end

  module ClefOctave0
    def octave
      elements[2]
    end
  end

  module ClefOctave1
    def set_clef_opts(opts)
      opts.merge!(:octave => opts[:octave].to_i + octave.value)
    end
  end

  def _nt_clef_octave
    start_index = index
    if node_cache[:clef_octave].has_key?(index)
      cached = node_cache[:clef_octave][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('octave', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure('octave')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_integer
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClefOctave0)
      r0.extend(ClefOctave1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef_octave][start_index] = r0

    r0
  end

  module ClefStafflines0
    def stafflines
      elements[2]
    end
  end

  module ClefStafflines1
    def set_clef_opts(opts)
      opts.merge!(:stafflines => stafflines.value)
    end
  end

  def _nt_clef_stafflines
    start_index = index
    if node_cache[:clef_stafflines].has_key?(index)
      cached = node_cache[:clef_stafflines][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('stafflines', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure('stafflines')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_wholenum
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClefStafflines0)
      r0.extend(ClefStafflines1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef_stafflines][start_index] = r0

    r0
  end

  module ClefName0
    def name
      elements[1]
    end

    def line_number
      elements[2]
    end

    def octave
      elements[3]
    end
  end

  module ClefName1
    def set_clef_opts(opts)
      opts[:name] = name.text_value
      opts[:line_number] = line_number.value 
      opts[:octave] = opts[:octave].to_i
      opts[:octave] += { '+8' => 1, '-8' => -1 }[octave.text_value] unless octave.empty?
      opts
    end
  end

  def _nt_clef_name
    start_index = index
    if node_cache[:clef_name].has_key?(index)
      cached = node_cache[:clef_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('clef=', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('clef=')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        if has_terminal?('\G[a-zA-Z]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
      if r3
        r6 = _nt_posint
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r5
        if r5
          i8 = index
          if has_terminal?('+8', false, index)
            r9 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('+8')
            r9 = nil
          end
          if r9
            r8 = r9
          else
            if has_terminal?('-8', false, index)
              r10 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('-8')
              r10 = nil
            end
            if r10
              r8 = r10
            else
              @index = i8
              r8 = nil
            end
          end
          if r8
            r7 = r8
          else
            r7 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r7
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClefName0)
      r0.extend(ClefName1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef_name][start_index] = r0

    r0
  end

  module ClefMiddle0
    def middle
      elements[2]
    end
  end

  module ClefMiddle1
    def set_clef_opts(opts)
      opts.merge!(:middle => middle.value)
    end
  end

  def _nt_clef_middle
    start_index = index
    if node_cache[:clef_middle].has_key?(index)
      cached = node_cache[:clef_middle][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('middle', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure('middle')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('m', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('m')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r4 = nil
      end
      s0 << r4
      if r4
        r5 = _nt_pitch
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClefMiddle0)
      r0.extend(ClefMiddle1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef_middle][start_index] = r0

    r0
  end

  module ClefAppSpecific0
    def app
      elements[0]
    end

    def field
      elements[2]
    end

    def value
      elements[4]
    end
  end

  module ClefAppSpecific1
    def set_clef_opts(opts)
      # TODO pass this data to the clef object
    end
  end

  def _nt_clef_app_specific
    start_index = index
    if node_cache[:clef_app_specific].has_key?(index)
      cached = node_cache[:clef_app_specific][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_alphanum
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      if has_terminal?(':', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(':')
        r3 = nil
      end
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_alphanum
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s0 << r4
        if r4
          if has_terminal?('=', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('=')
            r6 = nil
          end
          s0 << r6
          if r6
            s7, i7 = [], index
            loop do
              r8 = _nt_alphanum
              if r8
                s7 << r8
              else
                break
              end
            end
            if s7.empty?
              @index = i7
              r7 = nil
            else
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ClefAppSpecific0)
      r0.extend(ClefAppSpecific1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef_app_specific][start_index] = r0

    r0
  end

  def _nt_clef_specifier
    start_index = index
    if node_cache[:clef_specifier].has_key?(index)
      cached = node_cache[:clef_specifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_clef_transpose
    if r1
      r0 = r1
    else
      r2 = _nt_clef_octave
      if r2
        r0 = r2
      else
        r3 = _nt_clef_stafflines
        if r3
          r0 = r3
        else
          r4 = _nt_clef_middle
          if r4
            r0 = r4
          else
            r5 = _nt_clef_app_specific
            if r5
              r0 = r5
            else
              r6 = _nt_clef_name
              if r6
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:clef_specifier][start_index] = r0

    r0
  end

  module Clef0
    def specifier
      elements[1]
    end
  end

  module Clef1
    def first
      elements[0]
    end

    def extras
      elements[1]
    end
  end

  module Clef2
    def value
      @value ||= Clef.new(opts)
    end
    def opts
      @opts ||= extras.elements.inject(first.set_clef_opts({})) do |opts, node|
        node.specifier.set_clef_opts(opts)
        opts
      end
    end
  end

  def _nt_clef
    start_index = index
    if node_cache[:clef].has_key?(index)
      cached = node_cache[:clef][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_clef_specifier
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        s4, i4 = [], index
        loop do
          r5 = _nt_space
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s3 << r4
        if r4
          r6 = _nt_clef_specifier
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Clef0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Clef1)
      r0.extend(Clef2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:clef][start_index] = r0

    r0
  end

  def _nt_beam
    start_index = index
    if node_cache[:beam].has_key?(index)
      cached = node_cache[:beam][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("`", false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("`")
      r0 = nil
    end

    node_cache[:beam][start_index] = r0

    r0
  end

  module MusicSpace0
    def value
      @value ||= ABCElement.new(:beam_break)
    end
  end

  def _nt_music_space
    start_index = index
    if node_cache[:music_space].has_key?(index)
      cached = node_cache[:music_space][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_space
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(MusicSpace0)
    end

    node_cache[:music_space][start_index] = r0

    r0
  end

  module BarLine0
    def embellished_bar_line
      elements[0]
    end

  end

  def _nt_bar_line
    start_index = index
    if node_cache[:bar_line].has_key?(index)
      cached = node_cache[:bar_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_embellished_bar_line
    s0 << r1
    if r1
      r3 = _nt_variant_ending_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BarLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:bar_line][start_index] = r0

    r0
  end

  module EmbellishedBarLine0
    def embellishments
      elements[0]
    end

    def bare_bar_line
      elements[1]
    end
  end

  module EmbellishedBarLine1
    def value
      if @value
        @value
      else
        b = bare_bar_line.value(embellishments.value)
        # kludge to reinterpret a last . decoration as a dotted bar line marker
        # TODO should be last embellishment of any kind, not last decoration
        if b.decorations[-1] && b.decorations[-1].shortcut == "."
          b.decorations.pop
          b.dotted = true
        end
        @value = b
      end
    end
  end

  def _nt_embellished_bar_line
    start_index = index
    if node_cache[:embellished_bar_line].has_key?(index)
      cached = node_cache[:embellished_bar_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_embellishments
    s0 << r1
    if r1
      r2 = _nt_bare_bar_line
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(EmbellishedBarLine0)
      r0.extend(EmbellishedBarLine1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:embellished_bar_line][start_index] = r0

    r0
  end

  def _nt_bare_bar_line
    start_index = index
    if node_cache[:bare_bar_line].has_key?(index)
      cached = node_cache[:bare_bar_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_standard_bar_line
    if r1
      r0 = r1
    else
      r2 = _nt_double_colon_bar_line
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:bare_bar_line][start_index] = r0

    r0
  end

  module StandardBarLine0
    def before
      elements[0]
    end

    def bar
      elements[1]
    end

    def after
      elements[2]
    end
  end

  module StandardBarLine1
    def value(options={})
      BarLine.new(bar.type, before.count, after.count, options)
    end
  end

  def _nt_standard_bar_line
    start_index = index
    if node_cache[:standard_bar_line].has_key?(index)
      cached = node_cache[:standard_bar_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_repeat
    s0 << r1
    if r1
      r2 = _nt_bar
      s0 << r2
      if r2
        r3 = _nt_repeat
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(StandardBarLine0)
      r0.extend(StandardBarLine1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:standard_bar_line][start_index] = r0

    r0
  end

  module DoubleColonBarLine0
    def value(options={})
      BarLine.new(:thin, 1, 1, nil, options)
    end
  end

  def _nt_double_colon_bar_line
    start_index = index
    if node_cache[:double_colon_bar_line].has_key?(index)
      cached = node_cache[:double_colon_bar_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('::', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      r0.extend(DoubleColonBarLine0)
      @index += 2
    else
      terminal_parse_failure('::')
      r0 = nil
    end

    node_cache[:double_colon_bar_line][start_index] = r0

    r0
  end

  module Repeat0
    def count
      text_value.length
    end
  end

  def _nt_repeat
    start_index = index
    if node_cache[:repeat].has_key?(index)
      cached = node_cache[:repeat][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(':', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(':')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(Repeat0)

    node_cache[:repeat][start_index] = r0

    r0
  end

  module Bar0
  end

  module Bar1
    def type
      {'[|]' => :invisible,
        '||' => :double,
        '[|' => :thick_thin,
        '|]' => :thin_thick,
        '|' => :thin,
      }[text_value]
    end
  end

  def _nt_bar
    start_index = index
    if node_cache[:bar].has_key?(index)
      cached = node_cache[:bar][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?("[|]", false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("[|]")
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?("||", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("||")
        r3 = nil
      end
      if r3
        r1 = r3
      else
        if has_terminal?("[|", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("[|")
          r4 = nil
        end
        if r4
          r1 = r4
        else
          if has_terminal?("|]", false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure("|]")
            r5 = nil
          end
          if r5
            r1 = r5
          else
            if has_terminal?("|", false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("|")
              r6 = nil
            end
            if r6
              r1 = r6
            else
              @index = i1
              r1 = nil
            end
          end
        end
      end
    end
    s0 << r1
    if r1
      if has_terminal?('', false, index)
        r7 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure('')
        r7 = nil
      end
      s0 << r7
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Bar0)
      r0.extend(Bar1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:bar][start_index] = r0

    r0
  end

  module VariantEnding0
    def variant_ending_list
      elements[1]
    end
  end

  def _nt_variant_ending
    start_index = index
    if node_cache[:variant_ending].has_key?(index)
      cached = node_cache[:variant_ending][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('[', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_variant_ending_list
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VariantEnding0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:variant_ending][start_index] = r0

    r0
  end

  module VariantEndingList0
    def range_list
      elements[0]
    end

  end

  module VariantEndingList1
    def value
      @value ||= VariantEnding.new(range_list.value)
    end
  end

  def _nt_variant_ending_list
    start_index = index
    if node_cache[:variant_ending_list].has_key?(index)
      cached = node_cache[:variant_ending_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_range_list
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(VariantEndingList0)
      r0.extend(VariantEndingList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:variant_ending_list][start_index] = r0

    r0
  end

  module RangeList0
    def node
      elements[1]
    end
  end

  module RangeList1
    def first
      elements[0]
    end

    def rest
      elements[1]
    end
  end

  module RangeList2
    def value
      rest.elements.inject([first.value]) { |result, el| result << el.node.value }
    end
  end

  def _nt_range_list
    start_index = index
    if node_cache[:range_list].has_key?(index)
      cached = node_cache[:range_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_range
    if r2
      r1 = r2
    else
      r3 = _nt_posint
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      s4, i4 = [], index
      loop do
        i5, s5 = index, []
        if has_terminal?(',', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(',')
          r6 = nil
        end
        s5 << r6
        if r6
          i7 = index
          r8 = _nt_range
          if r8
            r7 = r8
          else
            r9 = _nt_posint
            if r9
              r7 = r9
            else
              @index = i7
              r7 = nil
            end
          end
          s5 << r7
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(RangeList0)
        else
          @index = i5
          r5 = nil
        end
        if r5
          s4 << r5
        else
          break
        end
      end
      r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
      s0 << r4
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RangeList1)
      r0.extend(RangeList2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:range_list][start_index] = r0

    r0
  end

  module Tie0
  end

  module Tie1
    def value
      @value ||= ABCElement.new(text_value[0] == '.' ? :dotted_tie : :tie)
    end
  end

  def _nt_tie
    start_index = index
    if node_cache[:tie].has_key?(index)
      cached = node_cache[:tie][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('.', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('.')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?('-', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('-')
        r3 = nil
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(Tie0)
      r0.extend(Tie1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tie][start_index] = r0

    r0
  end

  module Slur0
  end

  module Slur1
    def value
      @value ||= ABCElement.new(text_value == '.(' ? :start_dotted_slur : 
                                text_value == '(' ? :start_slur : :end_slur)
    end
  end

  def _nt_slur
    start_index = index
    if node_cache[:slur].has_key?(index)
      cached = node_cache[:slur][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('.(', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('.(')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('(', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('(')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        if has_terminal?(')', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(')')
          r4 = nil
        end
        if r4
          r1 = r4
        else
          @index = i1
          r1 = nil
        end
      end
    end
    s0 << r1
    if r1
      if has_terminal?('', false, index)
        r5 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure('')
        r5 = nil
      end
      s0 << r5
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(Slur0)
      r0.extend(Slur1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:slur][start_index] = r0

    r0
  end

  module GraceNote0
    def grace_note_series
      elements[2]
    end

  end

  module GraceNote1
    def value
      @value ||= GraceNotes.new(text_value[1] == '/' ? :acciaccatura : :appoggiatura, 
                                grace_note_series.value)
    end
  end

  def _nt_grace_note
    start_index = index
    if node_cache[:grace_note].has_key?(index)
      cached = node_cache[:grace_note][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('{', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('{')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('/', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('/')
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_grace_note_series
        s0 << r4
        if r4
          if has_terminal?('}', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('}')
            r5 = nil
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(GraceNote0)
      r0.extend(GraceNote1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:grace_note][start_index] = r0

    r0
  end

  module GraceNoteSeries0
    def br
      elements[0]
    end

    def note
      elements[1]
    end
  end

  module GraceNoteSeries1
    def first
      elements[0]
    end

    def rest
      elements[1]
    end
  end

  module GraceNoteSeries2
    def value
      @value ||= rest.elements.inject([first.value]) do |result, el|
        result << el.note.value(nil, :broken_rhythm_marker => el.br.value)
      end
    end
  end

  def _nt_grace_note_series
    start_index = index
    if node_cache[:grace_note_series].has_key?(index)
      cached = node_cache[:grace_note_series][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_note
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r5 = _nt_broken_rhythm
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_note
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(GraceNoteSeries0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(GraceNoteSeries1)
      r0.extend(GraceNoteSeries2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:grace_note_series][start_index] = r0

    r0
  end

  module TupletSymbol0
    def r
      elements[1]
    end
  end

  module TupletSymbol1
    def q
      elements[1]
    end

    def x
      elements[2]
    end
  end

  module TupletSymbol2
    def p
      elements[1]
    end

    def x
      elements[2]
    end
  end

  module TupletSymbol3
    def value
      q = (!x.empty? && !x.q.empty?) ? x.q.value : nil
      r = (!x.empty? && !x.x.empty? && !x.x.r.empty?) ? x.x.r.value : nil
      @value ||= TupletMarker.new(p.text_value.to_i, q, r)
    end
  end

  def _nt_tuplet_symbol
    start_index = index
    if node_cache[:tuplet_symbol].has_key?(index)
      cached = node_cache[:tuplet_symbol][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('\G[2-9]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      s0 << r2
      if r2
        i4, s4 = index, []
        if has_terminal?(':', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(':')
          r5 = nil
        end
        s4 << r5
        if r5
          r7 = _nt_posint
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s4 << r6
          if r6
            i9, s9 = index, []
            if has_terminal?(':', false, index)
              r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(':')
              r10 = nil
            end
            s9 << r10
            if r10
              r12 = _nt_posint
              if r12
                r11 = r12
              else
                r11 = instantiate_node(SyntaxNode,input, index...index)
              end
              s9 << r11
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(TupletSymbol0)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r8 = r9
            else
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s4 << r8
          end
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(TupletSymbol1)
        else
          @index = i4
          r4 = nil
        end
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(TupletSymbol2)
      r0.extend(TupletSymbol3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tuplet_symbol][start_index] = r0

    r0
  end

  def _nt_decoration
    start_index = index
    if node_cache[:decoration].has_key?(index)
      cached = node_cache[:decoration][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_explicit_declaration
    if r1
      r0 = r1
    else
      r2 = _nt_redefinable_symbol
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:decoration][start_index] = r0

    r0
  end

  module ExplicitDeclaration0
    def decoration_delimiter1
      elements[0]
    end

    def symbol
      elements[1]
    end

    def decoration_delimiter2
      elements[2]
    end
  end

  module ExplicitDeclaration1
    def value
      @value ||= Decoration.new(symbol.text_value, text_value)
    end
  end

  def _nt_explicit_declaration
    start_index = index
    if node_cache[:explicit_declaration].has_key?(index)
      cached = node_cache[:explicit_declaration][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_decoration_delimiter
    s0 << r1
    if r1
      r2 = _nt_legal_decoration_chars
      s0 << r2
      if r2
        r3 = _nt_decoration_delimiter
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ExplicitDeclaration0)
      r0.extend(ExplicitDeclaration1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:explicit_declaration][start_index] = r0

    r0
  end

  def _nt_decoration_delimiter
    start_index = index
    if node_cache[:decoration_delimiter].has_key?(index)
      cached = node_cache[:decoration_delimiter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('!', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('!')
      r0 = nil
    end

    node_cache[:decoration_delimiter][start_index] = r0

    r0
  end

  module LegalDecorationChars0
  end

  def _nt_legal_decoration_chars
    start_index = index
    if node_cache[:legal_decoration_chars].has_key?(index)
      cached = node_cache[:legal_decoration_chars][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1, s1 = index, []
      i2 = index
      i3 = index
      r4 = _nt_space
      if r4
        r3 = r4
      else
        if has_terminal?('[', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[')
          r5 = nil
        end
        if r5
          r3 = r5
        else
          if has_terminal?(']', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(']')
            r6 = nil
          end
          if r6
            r3 = r6
          else
            if has_terminal?('|', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('|')
              r7 = nil
            end
            if r7
              r3 = r7
            else
              if has_terminal?(':', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(':')
                r8 = nil
              end
              if r8
                r3 = r8
              else
                r9 = _nt_decoration_delimiter
                if r9
                  r3 = r9
                else
                  @index = i3
                  r3 = nil
                end
              end
            end
          end
        end
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r2
      if r2
        if index < input_length
          r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("any character")
          r10 = nil
        end
        s1 << r10
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(LegalDecorationChars0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:legal_decoration_chars][start_index] = r0

    r0
  end

  module SymbolLine0
    def symbol_sequence
      elements[1]
    end
  end

  module SymbolLine1
    def value
      @value ||= SymbolLine.new(symbol_sequence.value)
    end
  end

  def _nt_symbol_line
    start_index = index
    if node_cache[:symbol_line].has_key?(index)
      cached = node_cache[:symbol_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('s:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('s:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_symbol_sequence
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(SymbolLine0)
      r0.extend(SymbolLine1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:symbol_line][start_index] = r0

    r0
  end

  module SymbolSequence0
    def value
      @value ||= elements.map { |e| e.value }.select { |v| v != nil }
    end
  end

  def _nt_symbol_sequence
    start_index = index
    if node_cache[:symbol_sequence].has_key?(index)
      cached = node_cache[:symbol_sequence][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      if r2
        r1 = r2
      else
        r4 = _nt_symbol_skip
        if r4
          r1 = r4
        else
          r5 = _nt_chord_annotation
          if r5
            r1 = r5
          else
            r6 = _nt_annotation
            if r6
              r1 = r6
            else
              r7 = _nt_decoration
              if r7
                r1 = r7
              else
                @index = i1
                r1 = nil
              end
            end
          end
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(SymbolSequence0)

    node_cache[:symbol_sequence][start_index] = r0

    r0
  end

  module SymbolSkip0
    def value
      SymbolSkip.new(text_value == '*' ? :note : :bar)
    end
  end

  def _nt_symbol_skip
    start_index = index
    if node_cache[:symbol_skip].has_key?(index)
      cached = node_cache[:symbol_skip][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('*', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('*')
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(SymbolSkip0)
    else
      if has_terminal?('|', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('|')
        r2 = nil
      end
      if r2
        r0 = r2
        r0.extend(SymbolSkip0)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:symbol_skip][start_index] = r0

    r0
  end

  module RedefinableSymbol0
    def value
      @value ||= Decoration.new(nil, text_value)
    end
  end

  def _nt_redefinable_symbol
    start_index = index
    if node_cache[:redefinable_symbol].has_key?(index)
      cached = node_cache[:redefinable_symbol][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_shortcut_char
    r0.extend(RedefinableSymbol0)

    node_cache[:redefinable_symbol][start_index] = r0

    r0
  end

  def _nt_shortcut_char
    start_index = index
    if node_cache[:shortcut_char].has_key?(index)
      cached = node_cache[:shortcut_char][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[.~H-Wh-w]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:shortcut_char][start_index] = r0

    r0
  end

  module UserDefinedField0
    def shortcut_assignment
      elements[1]
    end

    def content
      elements[2]
    end
  end

  module UserDefinedField1
    def content_value
      if !@content_value
        @content_value = content.value
        @content_value.shortcut = shortcut_assignment.shortcut
      end
      @content_value
    end
  end

  def _nt_user_defined_field
    start_index = index
    if node_cache[:user_defined_field].has_key?(index)
      cached = node_cache[:user_defined_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('U:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('U:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_shortcut_assignment
      s0 << r2
      if r2
        r3 = _nt_embellishment_definition
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(UserDefinedField0)
      r0.extend(UserDefinedField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:user_defined_field][start_index] = r0

    r0
  end

  module ShortcutAssignment0
    def shortcut_char
      elements[1]
    end

  end

  module ShortcutAssignment1
    def shortcut
      shortcut_char.text_value
    end
  end

  def _nt_shortcut_assignment
    start_index = index
    if node_cache[:shortcut_assignment].has_key?(index)
      cached = node_cache[:shortcut_assignment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_field_space
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r3 = _nt_shortcut_char
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_field_space
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
        if r4
          if has_terminal?('=', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('=')
            r6 = nil
          end
          s0 << r6
          if r6
            s7, i7 = [], index
            loop do
              r8 = _nt_field_space
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ShortcutAssignment0)
      r0.extend(ShortcutAssignment1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:shortcut_assignment][start_index] = r0

    r0
  end

  def _nt_embellishment_definition
    start_index = index
    if node_cache[:embellishment_definition].has_key?(index)
      cached = node_cache[:embellishment_definition][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_nil_embellishment
    if r1
      r0 = r1
    else
      r2 = _nt_embellishment
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:embellishment_definition][start_index] = r0

    r0
  end

  module NilEmbellishment0
    def value
      Decoration.new(nil)
    end
  end

  def _nt_nil_embellishment
    start_index = index
    if node_cache[:nil_embellishment].has_key?(index)
      cached = node_cache[:nil_embellishment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('!nil!', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('!nil!')
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(NilEmbellishment0)
    else
      if has_terminal?('!none!', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 6))
        @index += 6
      else
        terminal_parse_failure('!none!')
        r2 = nil
      end
      if r2
        r0 = r2
        r0.extend(NilEmbellishment0)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:nil_embellishment][start_index] = r0

    r0
  end

  def _nt_embellishment
    start_index = index
    if node_cache[:embellishment].has_key?(index)
      cached = node_cache[:embellishment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_annotation
    if r1
      r0 = r1
    else
      r2 = _nt_decoration
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:embellishment][start_index] = r0

    r0
  end

  module Chord0
    def notes_node
      elements[1]
    end

    def note_length
      elements[3]
    end
  end

  module Chord1
    def value(embellishments, options)
      Chord.new(notes, note_length.value, embellishments, options)
    end
    def notes
      @notes ||= notes_node.elements.map { |node| node.value }
    end
  end

  def _nt_chord
    start_index = index
    if node_cache[:chord].has_key?(index)
      cached = node_cache[:chord][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('[', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_decorated_note
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        if has_terminal?(']', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(']')
          r4 = nil
        end
        s0 << r4
        if r4
          r5 = _nt_note_length
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Chord0)
      r0.extend(Chord1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:chord][start_index] = r0

    r0
  end

  module DecoratedNote0
    def embellishments
      elements[0]
    end

    def note
      elements[1]
    end
  end

  module DecoratedNote1
    def value(options={})
      note.value(embellishments.value, options)
    end
  end

  def _nt_decorated_note
    start_index = index
    if node_cache[:decorated_note].has_key?(index)
      cached = node_cache[:decorated_note][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_embellishments
    s0 << r1
    if r1
      r2 = _nt_note
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DecoratedNote0)
      r0.extend(DecoratedNote1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:decorated_note][start_index] = r0

    r0
  end

  module ChordAnnotation0
    def chord_symbol
      elements[1]
    end

  end

  module ChordAnnotation1
    def chord_symbol
      elements[0]
    end

  end

  module ChordAnnotation2
    def symbol
      elements[1]
    end

  end

  module ChordAnnotation3
    def value
      @value ||= ChordSymbol.new(symbol.text_value)
    end
  end

  def _nt_chord_annotation
    start_index = index
    if node_cache[:chord_annotation].has_key?(index)
      cached = node_cache[:chord_annotation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('"', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      i2, s2 = index, []
      r3 = _nt_chord_symbol
      s2 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_space
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s2 << r4
        if r4
          i7, s7 = index, []
          if has_terminal?('(', false, index)
            r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('(')
            r8 = nil
          end
          s7 << r8
          if r8
            r9 = _nt_chord_symbol
            s7 << r9
            if r9
              if has_terminal?(')', false, index)
                r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r10 = nil
              end
              s7 << r10
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(ChordAnnotation0)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s2 << r6
        end
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(ChordAnnotation1)
      else
        @index = i2
        r2 = nil
      end
      s0 << r2
      if r2
        if has_terminal?('"', false, index)
          r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r11 = nil
        end
        s0 << r11
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ChordAnnotation2)
      r0.extend(ChordAnnotation3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:chord_annotation][start_index] = r0

    r0
  end

  module ChordSymbol0
  end

  module ChordSymbol1
  end

  def _nt_chord_symbol
    start_index = index
    if node_cache[:chord_symbol].has_key?(index)
      cached = node_cache[:chord_symbol][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[A-G]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      i3 = index
      if has_terminal?('b', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('b')
        r4 = nil
      end
      if r4
        r3 = r4
      else
        if has_terminal?('#', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('#')
          r5 = nil
        end
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        s6, i6 = [], index
        loop do
          i7 = index
          if has_terminal?('min', false, index)
            r8 = instantiate_node(SyntaxNode,input, index...(index + 3))
            @index += 3
          else
            terminal_parse_failure('min')
            r8 = nil
          end
          if r8
            r7 = r8
          else
            if has_terminal?('maj', false, index)
              r9 = instantiate_node(SyntaxNode,input, index...(index + 3))
              @index += 3
            else
              terminal_parse_failure('maj')
              r9 = nil
            end
            if r9
              r7 = r9
            else
              if has_terminal?('m', false, index)
                r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('m')
                r10 = nil
              end
              if r10
                r7 = r10
              else
                if has_terminal?('dim', false, index)
                  r11 = instantiate_node(SyntaxNode,input, index...(index + 3))
                  @index += 3
                else
                  terminal_parse_failure('dim')
                  r11 = nil
                end
                if r11
                  r7 = r11
                else
                  if has_terminal?('aug', false, index)
                    r12 = instantiate_node(SyntaxNode,input, index...(index + 3))
                    @index += 3
                  else
                    terminal_parse_failure('aug')
                    r12 = nil
                  end
                  if r12
                    r7 = r12
                  else
                    if has_terminal?('+', false, index)
                      r13 = instantiate_node(SyntaxNode,input, index...(index + 1))
                      @index += 1
                    else
                      terminal_parse_failure('+')
                      r13 = nil
                    end
                    if r13
                      r7 = r13
                    else
                      if has_terminal?('sus', false, index)
                        r14 = instantiate_node(SyntaxNode,input, index...(index + 3))
                        @index += 3
                      else
                        terminal_parse_failure('sus')
                        r14 = nil
                      end
                      if r14
                        r7 = r14
                      else
                        r15 = _nt_posint
                        if r15
                          r7 = r15
                        else
                          r16 = _nt_space
                          if r16
                            r7 = r16
                          else
                            @index = i7
                            r7 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if r7
            s6 << r7
          else
            break
          end
        end
        r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
        s0 << r6
        if r6
          i18, s18 = index, []
          if has_terminal?('/', false, index)
            r19 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('/')
            r19 = nil
          end
          s18 << r19
          if r19
            if has_terminal?('\G[A-Ga-g]', true, index)
              r20 = true
              @index += 1
            else
              r20 = nil
            end
            s18 << r20
          end
          if s18.last
            r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
            r18.extend(ChordSymbol0)
          else
            @index = i18
            r18 = nil
          end
          if r18
            r17 = r18
          else
            r17 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r17
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ChordSymbol1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:chord_symbol][start_index] = r0

    r0
  end

  module Annotation0
  end

  module Annotation1
    def placement_specifier
      elements[1]
    end

    def text
      elements[2]
    end

  end

  module Annotation2
    def value
      @value ||= Annotation.new(placement_specifier.value, text.text_value)
    end
  end

  def _nt_annotation
    start_index = index
    if node_cache[:annotation].has_key?(index)
      cached = node_cache[:annotation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('"', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_placement_specifier
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          i5 = index
          if has_terminal?('"', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('"')
            r6 = nil
          end
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s4 << r5
          if r5
            if index < input_length
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("any character")
              r7 = nil
            end
            s4 << r7
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Annotation0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
        if r3
          if has_terminal?('"', false, index)
            r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('"')
            r8 = nil
          end
          s0 << r8
          if r8
            s9, i9 = [], index
            loop do
              r10 = _nt_space
              if r10
                s9 << r10
              else
                break
              end
            end
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            s0 << r9
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Annotation1)
      r0.extend(Annotation2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:annotation][start_index] = r0

    r0
  end

  module PlacementSpecifier0
    def value
      { '^' => :above, '_' => :below, '<' => :left, '>' => :right, 
        '@' => :unspecified }[text_value]
    end
  end

  def _nt_placement_specifier
    start_index = index
    if node_cache[:placement_specifier].has_key?(index)
      cached = node_cache[:placement_specifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('^', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('^')
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(PlacementSpecifier0)
    else
      if has_terminal?('_', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('_')
        r2 = nil
      end
      if r2
        r0 = r2
        r0.extend(PlacementSpecifier0)
      else
        if has_terminal?('<', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('<')
          r3 = nil
        end
        if r3
          r0 = r3
          r0.extend(PlacementSpecifier0)
        else
          if has_terminal?('>', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('>')
            r4 = nil
          end
          if r4
            r0 = r4
            r0.extend(PlacementSpecifier0)
          else
            if has_terminal?('@', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('@')
              r5 = nil
            end
            if r5
              r0 = r5
              r0.extend(PlacementSpecifier0)
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:placement_specifier][start_index] = r0

    r0
  end

  module NoteOrChord0
    def gb
      elements[0]
    end

    def embellishments
      elements[2]
    end

    def stroke
      elements[3]
    end
  end

  module NoteOrChord1
    def value
      @value ||= stroke.value(embellishments.value, gb.value)
    end
  end

  def _nt_note_or_chord
    start_index = index
    if node_cache[:note_or_chord].has_key?(index)
      cached = node_cache[:note_or_chord][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_grace_and_broken
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        r4 = _nt_space_or_ignored
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s0 << r3
      if r3
        r5 = _nt_embellishments
        s0 << r5
        if r5
          r6 = _nt_stroke
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(NoteOrChord0)
      r0.extend(NoteOrChord1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:note_or_chord][start_index] = r0

    r0
  end

  module GraceAndBroken0
    def gn
      elements[0]
    end

    def br
      elements[2]
    end
  end

  module GraceAndBroken1
    def br
      elements[0]
    end

    def gn
      elements[2]
    end
  end

  module GraceAndBroken2
    def value
      @value ||= { :grace_notes => gn.value, :broken_rhythm_marker => br.value }
    end
  end

  def _nt_grace_and_broken
    start_index = index
    if node_cache[:grace_and_broken].has_key?(index)
      cached = node_cache[:grace_and_broken][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_grace_note
    s1 << r2
    if r2
      s3, i3 = [], index
      loop do
        r4 = _nt_space_or_ignored
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s1 << r3
      if r3
        r6 = _nt_broken_rhythm
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r5
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(GraceAndBroken0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(GraceAndBroken2)
    else
      i7, s7 = index, []
      r8 = _nt_broken_rhythm
      s7 << r8
      if r8
        s9, i9 = [], index
        loop do
          r10 = _nt_space_or_ignored
          if r10
            s9 << r10
          else
            break
          end
        end
        r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
        s7 << r9
        if r9
          r12 = _nt_grace_note
          if r12
            r11 = r12
          else
            r11 = instantiate_node(SyntaxNode,input, index...index)
          end
          s7 << r11
        end
      end
      if s7.last
        r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
        r7.extend(GraceAndBroken1)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
        r0.extend(GraceAndBroken2)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:grace_and_broken][start_index] = r0

    r0
  end

  module Embellishments0
    def chord
      elements[0]
    end

    def annotations_and_decorations
      elements[2]
    end
  end

  module Embellishments1
    def value
      @value ||= [chord.value, *annotations_and_decorations.value].select { |v| v != nil }
    end
  end

  def _nt_embellishments
    start_index = index
    if node_cache[:embellishments].has_key?(index)
      cached = node_cache[:embellishments][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_chord_annotation
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        r4 = _nt_space_or_ignored
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s0 << r3
      if r3
        r5 = _nt_annotations_and_decorations
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Embellishments0)
      r0.extend(Embellishments1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:embellishments][start_index] = r0

    r0
  end

  module AnnotationsAndDecorations0
    def node
      elements[0]
    end

  end

  module AnnotationsAndDecorations1
    def value
      elements.map { |el| el.node.value }
    end
  end

  def _nt_annotations_and_decorations
    start_index = index
    if node_cache[:annotations_and_decorations].has_key?(index)
      cached = node_cache[:annotations_and_decorations][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1, s1 = index, []
      i2 = index
      r3 = _nt_annotation
      if r3
        r2 = r3
      else
        r4 = _nt_decoration
        if r4
          r2 = r4
        else
          @index = i2
          r2 = nil
        end
      end
      s1 << r2
      if r2
        s5, i5 = [], index
        loop do
          r6 = _nt_space_or_ignored
          if r6
            s5 << r6
          else
            break
          end
        end
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        s1 << r5
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(AnnotationsAndDecorations0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(AnnotationsAndDecorations1)

    node_cache[:annotations_and_decorations][start_index] = r0

    r0
  end

  def _nt_stroke
    start_index = index
    if node_cache[:stroke].has_key?(index)
      cached = node_cache[:stroke][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_chord
    if r1
      r0 = r1
    else
      r2 = _nt_note
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:stroke][start_index] = r0

    r0
  end

  module Note0
    def pitch
      elements[0]
    end

    def note_length
      elements[1]
    end
  end

  module Note1
    def value(embellishments=nil, options={})
      Note.new(pitch.value, note_length.value, embellishments, options)
    end
  end

  def _nt_note
    start_index = index
    if node_cache[:note].has_key?(index)
      cached = node_cache[:note][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_pitch
    s0 << r1
    if r1
      r2 = _nt_note_length
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Note0)
      r0.extend(Note1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:note][start_index] = r0

    r0
  end

  module LyricsLine0
    def lyrics_sequence
      elements[1]
    end
  end

  module LyricsLine1
    def value
      @value ||= LyricsLine.new(lyrics_sequence.value)
    end
  end

  def _nt_lyrics_line
    start_index = index
    if node_cache[:lyrics_line].has_key?(index)
      cached = node_cache[:lyrics_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('w:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('w:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_lyrics_sequence
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(LyricsLine0)
      r0.extend(LyricsLine1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:lyrics_line][start_index] = r0

    r0
  end

  module LyricsSequence0
    def text
      elements[1]
    end
  end

  module LyricsSequence1
    def value
      @value ||= elements.map { |e| e.text.value }.select { |v| v != nil }
    end
  end

  def _nt_lyrics_sequence
    start_index = index
    if node_cache[:lyrics_sequence].has_key?(index)
      cached = node_cache[:lyrics_sequence][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1, s1 = index, []
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s1 << r2
      if r2
        i4 = index
        r5 = _nt_lyrics_unit
        if r5
          r4 = r5
        else
          r6 = _nt_symbol_skip
          if r6
            r4 = r6
          else
            @index = i4
            r4 = nil
          end
        end
        s1 << r4
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(LyricsSequence0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(LyricsSequence1)

    node_cache[:lyrics_sequence][start_index] = r0

    r0
  end

  module LyricsUnit0
  end

  module LyricsUnit1
    def prehyphen
      elements[0]
    end

    def lyrics_word
      elements[1]
    end

    def hyphen
      elements[2]
    end

    def stretch
      elements[3]
    end
  end

  module LyricsUnit2
    def value
      LyricsUnit.new(lyrics_word.value, hyphen.text_value, stretch.text_value, 
                     prehyphen.text_value)
    end
  end

  def _nt_lyrics_unit
    start_index = index
    if node_cache[:lyrics_unit].has_key?(index)
      cached = node_cache[:lyrics_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      if has_terminal?('-', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('-')
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r3 = _nt_lyrics_word
      s0 << r3
      if r3
        i5, s5 = index, []
        r7 = _nt_space
        if r7
          r6 = r7
        else
          r6 = instantiate_node(SyntaxNode,input, index...index)
        end
        s5 << r6
        if r6
          s8, i8 = [], index
          loop do
            if has_terminal?('-', false, index)
              r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('-')
              r9 = nil
            end
            if r9
              s8 << r9
            else
              break
            end
          end
          if s8.empty?
            @index = i8
            r8 = nil
          else
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          end
          s5 << r8
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(LyricsUnit0)
        else
          @index = i5
          r5 = nil
        end
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          s10, i10 = [], index
          loop do
            if has_terminal?('_', false, index)
              r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('_')
              r11 = nil
            end
            if r11
              s10 << r11
            else
              break
            end
          end
          r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
          s0 << r10
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LyricsUnit1)
      r0.extend(LyricsUnit2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:lyrics_unit][start_index] = r0

    r0
  end

  module LyricsWord0
    def value
      text_value.gsub('\\-', '-').gsub('~', ' ')
    end
  end

  def _nt_lyrics_word
    start_index = index
    if node_cache[:lyrics_word].has_key?(index)
      cached = node_cache[:lyrics_word][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      if has_terminal?("\\-", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("\\-")
        r2 = nil
      end
      if r2
        r1 = r2
      else
        if has_terminal?('\G[^ _\\-\\*\\|\\n]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LyricsWord0)
    end

    node_cache[:lyrics_word][start_index] = r0

    r0
  end

  module ScoreLinebreakDollar0
    def value
      ABCElement::SCORE_LINEBREAK
    end
  end

  def _nt_score_linebreak_dollar
    start_index = index
    if node_cache[:score_linebreak_dollar].has_key?(index)
      cached = node_cache[:score_linebreak_dollar][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('$', false, index)
      r0 = instantiate_node(ValueNode,input, index...(index + 1))
      r0.extend(ScoreLinebreakDollar0)
      @index += 1
    else
      terminal_parse_failure('$')
      r0 = nil
    end

    node_cache[:score_linebreak_dollar][start_index] = r0

    r0
  end

  module ScoreLinebreakBang0
    def value
      ABCElement::SCORE_LINEBREAK
    end
  end

  def _nt_score_linebreak_bang
    start_index = index
    if node_cache[:score_linebreak_bang].has_key?(index)
      cached = node_cache[:score_linebreak_bang][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('!', false, index)
      r0 = instantiate_node(ValueNode,input, index...(index + 1))
      r0.extend(ScoreLinebreakBang0)
      @index += 1
    else
      terminal_parse_failure('!')
      r0 = nil
    end

    node_cache[:score_linebreak_bang][start_index] = r0

    r0
  end

  def _nt_score_linebreak_none
    start_index = index
    if node_cache[:score_linebreak_none].has_key?(index)
      cached = node_cache[:score_linebreak_none][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_match_nothing

    node_cache[:score_linebreak_none][start_index] = r0

    r0
  end

  def _nt_score_linebreak_both
    start_index = index
    if node_cache[:score_linebreak_both].has_key?(index)
      cached = node_cache[:score_linebreak_both][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_score_linebreak_dollar
    if r1
      r0 = r1
    else
      r2 = _nt_score_linebreak_bang
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:score_linebreak_both][start_index] = r0

    r0
  end

  def _nt_score_linebreak_default
    start_index = index
    if node_cache[:score_linebreak_default].has_key?(index)
      cached = node_cache[:score_linebreak_default][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_score_linebreak_dollar

    node_cache[:score_linebreak_default][start_index] = r0

    r0
  end

  def _nt_score_linebreak
    start_index = index
    if node_cache[:score_linebreak].has_key?(index)
      cached = node_cache[:score_linebreak][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_score_linebreak_dollar

    node_cache[:score_linebreak][start_index] = r0

    r0
  end

  module Spacer0
    def embellishments
      elements[0]
    end

  end

  module Spacer1
    def value
      @value ||= Spacer.new(embellishments.value)
    end
  end

  def _nt_spacer
    start_index = index
    if node_cache[:spacer].has_key?(index)
      cached = node_cache[:spacer][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_embellishments
    s0 << r1
    if r1
      if has_terminal?('y', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('y')
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(Spacer0)
      r0.extend(Spacer1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:spacer][start_index] = r0

    r0
  end

  module VoiceBodyField0
    def content
      elements[1]
    end
  end

  module VoiceBodyField1
    def type
      :voice_marker
    end
  end

  def _nt_voice_body_field
    start_index = index
    if node_cache[:voice_body_field].has_key?(index)
      cached = node_cache[:voice_body_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('V:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('V:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_voice_id
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(VoiceBodyField0)
      r0.extend(VoiceBodyField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:voice_body_field][start_index] = r0

    r0
  end

  module VoiceName0
    def name
      elements[2]
    end
  end

  module VoiceName1
    def set_voice_opts(opts)
      opts.merge!(:name => name.value)
    end
  end

  def _nt_voice_name
    start_index = index
    if node_cache[:voice_name].has_key?(index)
      cached = node_cache[:voice_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('name', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('name')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('nm', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('nm')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r4 = nil
      end
      s0 << r4
      if r4
        r5 = _nt_quoted_string
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VoiceName0)
      r0.extend(VoiceName1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:voice_name][start_index] = r0

    r0
  end

  module VoiceSubname0
    def subname
      elements[2]
    end
  end

  module VoiceSubname1
    def set_voice_opts(opts)
      opts.merge!(:subname => subname.value)
    end
  end

  def _nt_voice_subname
    start_index = index
    if node_cache[:voice_subname].has_key?(index)
      cached = node_cache[:voice_subname][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if has_terminal?('subname', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure('subname')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('snm', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure('snm')
        r3 = nil
      end
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r4 = nil
      end
      s0 << r4
      if r4
        r5 = _nt_quoted_string
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VoiceSubname0)
      r0.extend(VoiceSubname1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:voice_subname][start_index] = r0

    r0
  end

  module VoiceStem0
    def stem
      elements[2]
    end
  end

  module VoiceStem1
    def set_voice_opts(opts)
      opts.merge!(:stem => stem.text_value.to_sym)
    end
  end

  def _nt_voice_stem
    start_index = index
    if node_cache[:voice_stem].has_key?(index)
      cached = node_cache[:voice_stem][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('stem', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('stem')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('=', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r2 = nil
      end
      s0 << r2
      if r2
        i3 = index
        if has_terminal?('up', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('up')
          r4 = nil
        end
        if r4
          r3 = r4
        else
          if has_terminal?('down', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 4))
            @index += 4
          else
            terminal_parse_failure('down')
            r5 = nil
          end
          if r5
            r3 = r5
          else
            @index = i3
            r3 = nil
          end
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VoiceStem0)
      r0.extend(VoiceStem1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:voice_stem][start_index] = r0

    r0
  end

  def _nt_voice_specifier
    start_index = index
    if node_cache[:voice_specifier].has_key?(index)
      cached = node_cache[:voice_specifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_voice_name
    if r1
      r0 = r1
    else
      r2 = _nt_voice_subname
      if r2
        r0 = r2
      else
        r3 = _nt_voice_stem
        if r3
          r0 = r3
        else
          r4 = _nt_clef_specifier
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:voice_specifier][start_index] = r0

    r0
  end

  module VoiceHeaderField0
    def content
      elements[1]
    end
  end

  def _nt_voice_header_field
    start_index = index
    if node_cache[:voice_header_field].has_key?(index)
      cached = node_cache[:voice_header_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('V:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('V:')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_voice_definition
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(VoiceHeaderField0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:voice_header_field][start_index] = r0

    r0
  end

  module VoiceDefinition0
    def spec
      elements[1]
    end
  end

  module VoiceDefinition1
    def voice_id
      elements[0]
    end

    def specifiers
      elements[1]
    end
  end

  module VoiceDefinition2
    def value
      @value ||= Voice.new(voice_id.value, opts)
    end
    def opts
      @opts ||= specifiers.elements.inject({ :clef => {} }) do |opts, node|
        node.spec.set_voice_opts(opts) if node.spec.respond_to?(:set_voice_opts)
        node.spec.set_clef_opts(opts[:clef]) if node.spec.respond_to?(:set_clef_opts)
        opts
      end
    end
  end

  def _nt_voice_definition
    start_index = index
    if node_cache[:voice_definition].has_key?(index)
      cached = node_cache[:voice_definition][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_voice_id
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        s4, i4 = [], index
        loop do
          r5 = _nt_space
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s3 << r4
        if r4
          r6 = _nt_voice_specifier
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(VoiceDefinition0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VoiceDefinition1)
      r0.extend(VoiceDefinition2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:voice_definition][start_index] = r0

    r0
  end

  module VoiceId0
    def value
      text_value[0..19] # first 20 chars only
    end
  end

  def _nt_voice_id
    start_index = index
    if node_cache[:voice_id].has_key?(index)
      cached = node_cache[:voice_id][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_alphanum
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VoiceId0)
    end

    node_cache[:voice_id][start_index] = r0

    r0
  end

  module OverlayDelimiter0
    def value
      @value ||= OverlayMarker.new(text_value.length)
    end
  end

  def _nt_overlay_delimiter
    start_index = index
    if node_cache[:overlay_delimiter].has_key?(index)
      cached = node_cache[:overlay_delimiter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('&', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('&')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(ValueNode,input, i0...index, s0)
      r0.extend(OverlayDelimiter0)
    end

    node_cache[:overlay_delimiter][start_index] = r0

    r0
  end

  module IgnoredChar0
    # TODO: issue warning
         def warning
           "ignored char: #{text_value}"
         end
  end

  def _nt_ignored_char
    start_index = index
    if node_cache[:ignored_char].has_key?(index)
      cached = node_cache[:ignored_char][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?("#", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("#")
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(IgnoredChar0)
    else
      if has_terminal?("*", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("*")
        r2 = nil
      end
      if r2
        r0 = r2
        r0.extend(IgnoredChar0)
      else
        if has_terminal?(";", false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(";")
          r3 = nil
        end
        if r3
          r0 = r3
          r0.extend(IgnoredChar0)
        else
          if has_terminal?("?", false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("?")
            r4 = nil
          end
          if r4
            r0 = r4
            r0.extend(IgnoredChar0)
          else
            if has_terminal?("@", false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("@")
              r5 = nil
            end
            if r5
              r0 = r5
              r0.extend(IgnoredChar0)
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:ignored_char][start_index] = r0

    r0
  end

  def _nt_space_or_ignored
    start_index = index
    if node_cache[:space_or_ignored].has_key?(index)
      cached = node_cache[:space_or_ignored][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_space
    if r1
      r0 = r1
    else
      r2 = _nt_ignored_char
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:space_or_ignored][start_index] = r0

    r0
  end

  module MacroField0
    def macro_target
      elements[2]
    end

    def macro_replace
      elements[6]
    end
  end

  module MacroField1
    def content_value
      { target => replacement }
    end
    def target
      macro_target.text_value
    end
    def replacement
      macro_replace.value
    end
  end

  def _nt_macro_field
    start_index = index
    if node_cache[:macro_field].has_key?(index)
      cached = node_cache[:macro_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('m:', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('m:')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_macro_target
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_field_space
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            if has_terminal?('=', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('=')
              r7 = nil
            end
            s0 << r7
            if r7
              s8, i8 = [], index
              loop do
                r9 = _nt_field_space
                if r9
                  s8 << r9
                else
                  break
                end
              end
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              s0 << r8
              if r8
                r10 = _nt_macro_replace
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(MacroFieldNode,input, i0...index, s0)
      r0.extend(MacroField0)
      r0.extend(MacroField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:macro_field][start_index] = r0

    r0
  end

  module MacroTarget0
  end

  def _nt_macro_target
    start_index = index
    if node_cache[:macro_target].has_key?(index)
      cached = node_cache[:macro_target][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1, s1 = index, []
      i2 = index
      if has_terminal?('\G[ \\t=]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r2
      if r2
        if index < input_length
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("any character")
          r4 = nil
        end
        s1 << r4
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(MacroTarget0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:macro_target][start_index] = r0

    r0
  end

  def _nt_macro_replace
    start_index = index
    if node_cache[:macro_replace].has_key?(index)
      cached = node_cache[:macro_replace][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_string_field_content

    node_cache[:macro_replace][start_index] = r0

    r0
  end

  def _nt_pseudo_comment
    start_index = index
    if node_cache[:pseudo_comment].has_key?(index)
      cached = node_cache[:pseudo_comment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_instruction_field

    node_cache[:pseudo_comment][start_index] = r0

    r0
  end

  module StavesField0
    def instruction_field_identifier
      elements[0]
    end

    def directive
      elements[1]
    end

    def staves
      elements[3]
    end
  end

  module StavesField1
    def value
      @value ||= InstructionField.new(text_value[0], 'staves', 
                                      staves.value(directive.text_value == 'staves'))
    end
  end

  def _nt_staves_field
    start_index = index
    if node_cache[:staves_field].has_key?(index)
      cached = node_cache[:staves_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      i2 = index
      if has_terminal?('score', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('score')
        r3 = nil
      end
      if r3
        r2 = r3
      else
        if has_terminal?('staves', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 6))
          @index += 6
        else
          terminal_parse_failure('staves')
          r4 = nil
        end
        if r4
          r2 = r4
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
      if r2
        s5, i5 = [], index
        loop do
          r6 = _nt_field_space
          if r6
            s5 << r6
          else
            break
          end
        end
        if s5.empty?
          @index = i5
          r5 = nil
        else
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        end
        s0 << r5
        if r5
          r7 = _nt_staves
          s0 << r7
        end
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(StavesField0)
      r0.extend(StavesField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:staves_field][start_index] = r0

    r0
  end

  module Staves0
    def item
      elements[1]
    end
  end

  module Staves1
    def first
      elements[0]
    end

    def rest
      elements[1]
    end
  end

  module Staves2
    def value(invert_bar_continuation=false)
      Staff::list(item_values, :invert_bar_continuation => invert_bar_continuation)
    end
  end

  def _nt_staves
    start_index = index
    if node_cache[:staves].has_key?(index)
      cached = node_cache[:staves][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_voice_block
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        s4, i4 = [], index
        loop do
          r5 = _nt_field_space
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s3 << r4
        if r4
          r6 = _nt_voice_block
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Staves0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Staves1)
      r0.extend(Staves2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:staves][start_index] = r0

    r0
  end

  module Staff0
    def voices
      elements[0]
    end

    def fv
      elements[1]
    end

    def bc
      elements[2]
    end
  end

  module Staff1
    def value
      @value ||= Staff.new(voices.value,
                :floaters => fv.elements.map { |el| el.value },
                :continue_bar_lines => !bc.empty?)
    end
  end

  def _nt_staff
    start_index = index
    if node_cache[:staff].has_key?(index)
      cached = node_cache[:staff][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_single_voice_staff
    if r2
      r1 = r2
    else
      r3 = _nt_multivoice_staff
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      s4, i4 = [], index
      loop do
        r5 = _nt_floating_voice
        if r5
          s4 << r5
        else
          break
        end
      end
      r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
      s0 << r4
      if r4
        r7 = _nt_bar_continuation
        if r7
          r6 = r7
        else
          r6 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r6
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Staff0)
      r0.extend(Staff1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:staff][start_index] = r0

    r0
  end

  module SingleVoiceStaff0
    def voice_id
      elements[0]
    end

  end

  module SingleVoiceStaff1
    def value
      @value ||= [voice_id.value]
    end
  end

  def _nt_single_voice_staff
    start_index = index
    if node_cache[:single_voice_staff].has_key?(index)
      cached = node_cache[:single_voice_staff][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_voice_id
    s0 << r1
    if r1
      if has_terminal?('', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure('')
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SingleVoiceStaff0)
      r0.extend(SingleVoiceStaff1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:single_voice_staff][start_index] = r0

    r0
  end

  module MultivoiceStaff0
    def item
      elements[1]
    end
  end

  module MultivoiceStaff1
    def first
      elements[2]
    end

    def rest
      elements[3]
    end

  end

  module MultivoiceStaff2
    def value
      @value ||= item_values
    end
  end

  def _nt_multivoice_staff
    start_index = index
    if node_cache[:multivoice_staff].has_key?(index)
      cached = node_cache[:multivoice_staff][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_voice_id
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            s7, i7 = [], index
            loop do
              r8 = _nt_field_space
              if r8
                s7 << r8
              else
                break
              end
            end
            if s7.empty?
              @index = i7
              r7 = nil
            else
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            end
            s6 << r7
            if r7
              r9 = _nt_voice_id
              s6 << r9
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(MultivoiceStaff0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            s10, i10 = [], index
            loop do
              r11 = _nt_field_space
              if r11
                s10 << r11
              else
                break
              end
            end
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            s0 << r10
            if r10
              if has_terminal?(')', false, index)
                r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r12 = nil
              end
              s0 << r12
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MultivoiceStaff1)
      r0.extend(MultivoiceStaff2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:multivoice_staff][start_index] = r0

    r0
  end

  module FloatingVoice0
    def voice_id
      elements[2]
    end
  end

  module FloatingVoice1
    def value
      voice_id.value
    end
  end

  def _nt_floating_voice
    start_index = index
    if node_cache[:floating_voice].has_key?(index)
      cached = node_cache[:floating_voice][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_field_space
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      if has_terminal?('*', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('*')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_voice_id
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FloatingVoice0)
      r0.extend(FloatingVoice1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:floating_voice][start_index] = r0

    r0
  end

  module BarContinuation0
  end

  def _nt_bar_continuation
    start_index = index
    if node_cache[:bar_continuation].has_key?(index)
      cached = node_cache[:bar_continuation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_field_space
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      if has_terminal?('|', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('|')
        r3 = nil
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BarContinuation0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:bar_continuation][start_index] = r0

    r0
  end

  module BracedStaves0
    def item
      elements[1]
    end
  end

  module BracedStaves1
    def first
      elements[2]
    end

    def rest
      elements[3]
    end

  end

  module BracedStaves2
    def value
      @value ||= Staff::list(item_values, :type => :braced)
    end
  end

  def _nt_braced_staves
    start_index = index
    if node_cache[:braced_staves].has_key?(index)
      cached = node_cache[:braced_staves][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('{', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('{')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_staff
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            s7, i7 = [], index
            loop do
              r8 = _nt_field_space
              if r8
                s7 << r8
              else
                break
              end
            end
            if s7.empty?
              @index = i7
              r7 = nil
            else
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            end
            s6 << r7
            if r7
              r9 = _nt_staff
              s6 << r9
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(BracedStaves0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            s10, i10 = [], index
            loop do
              r11 = _nt_field_space
              if r11
                s10 << r11
              else
                break
              end
            end
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            s0 << r10
            if r10
              if has_terminal?('}', false, index)
                r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('}')
                r12 = nil
              end
              s0 << r12
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BracedStaves1)
      r0.extend(BracedStaves2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:braced_staves][start_index] = r0

    r0
  end

  def _nt_staff_unit
    start_index = index
    if node_cache[:staff_unit].has_key?(index)
      cached = node_cache[:staff_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_staff
    if r1
      r0 = r1
    else
      r2 = _nt_braced_staves
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:staff_unit][start_index] = r0

    r0
  end

  module BracketedStaves0
    def item
      elements[1]
    end
  end

  module BracketedStaves1
    def first
      elements[2]
    end

    def rest
      elements[3]
    end

  end

  module BracketedStaves2
    def value
      @value ||= Staff::list(item_values, :type => :bracketed)
    end
  end

  def _nt_bracketed_staves
    start_index = index
    if node_cache[:bracketed_staves].has_key?(index)
      cached = node_cache[:bracketed_staves][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('[', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_staff_unit
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            s7, i7 = [], index
            loop do
              r8 = _nt_field_space
              if r8
                s7 << r8
              else
                break
              end
            end
            if s7.empty?
              @index = i7
              r7 = nil
            else
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            end
            s6 << r7
            if r7
              r9 = _nt_staff_unit
              s6 << r9
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(BracketedStaves0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            s10, i10 = [], index
            loop do
              r11 = _nt_field_space
              if r11
                s10 << r11
              else
                break
              end
            end
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            s0 << r10
            if r10
              if has_terminal?(']', false, index)
                r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(']')
                r12 = nil
              end
              s0 << r12
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BracketedStaves1)
      r0.extend(BracketedStaves2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:bracketed_staves][start_index] = r0

    r0
  end

  def _nt_voice_block
    start_index = index
    if node_cache[:voice_block].has_key?(index)
      cached = node_cache[:voice_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_staff_unit
    if r1
      r0 = r1
    else
      r2 = _nt_bracketed_staves
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:voice_block][start_index] = r0

    r0
  end

  module MidiField0
    def instruction_field_identifier
      elements[0]
    end

    def midi_directive
      elements[3]
    end
  end

  module MidiField1
    def value
      @value ||= InstructionField.new(text_value[0], 'MIDI', midi_directive.value,
                                      :subdirective => midi_directive.directive.text_value)
    end
  end

  def _nt_midi_field
    start_index = index
    if node_cache[:midi_field].has_key?(index)
      cached = node_cache[:midi_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      if has_terminal?('MIDI', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 4))
        @index += 4
      else
        terminal_parse_failure('MIDI')
        r2 = nil
      end
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_field_space
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s0 << r3
        if r3
          r5 = _nt_midi_directive
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(MidiField0)
      r0.extend(MidiField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:midi_field][start_index] = r0

    r0
  end

  def _nt_midi_directive
    start_index = index
    if node_cache[:midi_directive].has_key?(index)
      cached = node_cache[:midi_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_midi_voice_directive
    if r1
      r0 = r1
    else
      r2 = _nt_midi_chordprog_directive
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:midi_directive][start_index] = r0

    r0
  end

  module MidiVoiceDirective0
  end

  module MidiVoiceDirective1
    def directive
      elements[0]
    end

    def id
      elements[1]
    end

    def instr
      elements[2]
    end

    def mute
      elements[3]
    end
  end

  module MidiVoiceDirective2
    def value
      @value ||= MidiVoice.new(id.value,
                               instr.empty? ? nil : instr.instrument, 
                               instr.empty? ? nil : instr.bank,
                               !mute.empty?)
    end
  end

  def _nt_midi_voice_directive
    start_index = index
    if node_cache[:midi_voice_directive].has_key?(index)
      cached = node_cache[:midi_voice_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('voice', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('voice')
      r1 = nil
    end
    s0 << r1
    if r1
      r3 = _nt_midi_voice_id
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r5 = _nt_midi_instrument
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          i7, s7 = index, []
          s8, i8 = [], index
          loop do
            r9 = _nt_field_space
            if r9
              s8 << r9
            else
              break
            end
          end
          if s8.empty?
            @index = i8
            r8 = nil
          else
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          end
          s7 << r8
          if r8
            if has_terminal?('mute', false, index)
              r10 = instantiate_node(SyntaxNode,input, index...(index + 4))
              @index += 4
            else
              terminal_parse_failure('mute')
              r10 = nil
            end
            s7 << r10
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(MidiVoiceDirective0)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MidiVoiceDirective1)
      r0.extend(MidiVoiceDirective2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:midi_voice_directive][start_index] = r0

    r0
  end

  module MidiVoiceId0
    def voice_id
      elements[2]
    end
  end

  module MidiVoiceId1
    def value
      voice_id.value
    end
  end

  def _nt_midi_voice_id
    start_index = index
    if node_cache[:midi_voice_id].has_key?(index)
      cached = node_cache[:midi_voice_id][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_field_space
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      i3 = index
      i4 = index
      if has_terminal?('instrument=', false, index)
        r5 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('instrument=')
        r5 = nil
      end
      if r5
        r4 = r5
      else
        if has_terminal?('mute', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure('mute')
          r6 = nil
        end
        if r6
          r4 = r6
        else
          @index = i4
          r4 = nil
        end
      end
      if r4
        r3 = nil
      else
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r7 = _nt_voice_id
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MidiVoiceId0)
      r0.extend(MidiVoiceId1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:midi_voice_id][start_index] = r0

    r0
  end

  module MidiInstrument0
    def item
      elements[2]
    end
  end

  module MidiInstrument1
    def instr
      elements[2]
    end

    def bank
      elements[3]
    end
  end

  module MidiInstrument2
    def instrument
      instr.value
    end
    def bank
      super.empty? ? nil : super.item.value
    end
  end

  def _nt_midi_instrument
    start_index = index
    if node_cache[:midi_instrument].has_key?(index)
      cached = node_cache[:midi_instrument][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_field_space
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      if has_terminal?('instrument=', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('instrument=')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_posint
        s0 << r4
        if r4
          i6, s6 = index, []
          s7, i7 = [], index
          loop do
            r8 = _nt_field_space
            if r8
              s7 << r8
            else
              break
            end
          end
          if s7.empty?
            @index = i7
            r7 = nil
          else
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          end
          s6 << r7
          if r7
            if has_terminal?('bank=', false, index)
              r9 = instantiate_node(SyntaxNode,input, index...(index + 5))
              @index += 5
            else
              terminal_parse_failure('bank=')
              r9 = nil
            end
            s6 << r9
            if r9
              r10 = _nt_posint
              s6 << r10
            end
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(MidiInstrument0)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MidiInstrument1)
      r0.extend(MidiInstrument2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:midi_instrument][start_index] = r0

    r0
  end

  module MidiChordprogDirective0
    def directive
      elements[0]
    end

    def instr
      elements[2]
    end
  end

  module MidiChordprogDirective1
    def value
      instr.value
    end
  end

  def _nt_midi_chordprog_directive
    start_index = index
    if node_cache[:midi_chordprog_directive].has_key?(index)
      cached = node_cache[:midi_chordprog_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('chordprog', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure('chordprog')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_posint
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MidiChordprogDirective0)
      r0.extend(MidiChordprogDirective1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:midi_chordprog_directive][start_index] = r0

    r0
  end

  module FormattingField0
    def instruction_field_identifier
      elements[0]
    end

    def pred
      elements[1]
    end
  end

  module FormattingField1
    def value
      @value ||= InstructionField.new(text_value[0], pred.directive.text_value, 
                                      pred.parameter.value)
    end
  end

  def _nt_formatting_field
    start_index = index
    if node_cache[:formatting_field].has_key?(index)
      cached = node_cache[:formatting_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      r2 = _nt_formatting_predicate
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(FormattingField0)
      r0.extend(FormattingField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:formatting_field][start_index] = r0

    r0
  end

  def _nt_formatting_predicate
    start_index = index
    if node_cache[:formatting_predicate].has_key?(index)
      cached = node_cache[:formatting_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_string_predicate
    if r1
      r0 = r1
    else
      r2 = _nt_logical_predicate
      if r2
        r0 = r2
      else
        r3 = _nt_integer_predicate
        if r3
          r0 = r3
        else
          r4 = _nt_number_predicate
          if r4
            r0 = r4
          else
            r5 = _nt_length_predicate
            if r5
              r0 = r5
            else
              r6 = _nt_font_predicate
              if r6
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:formatting_predicate][start_index] = r0

    r0
  end

  module StringPredicate0
    def directive
      elements[0]
    end

    def parameter
      elements[2]
    end
  end

  def _nt_string_predicate
    start_index = index
    if node_cache[:string_predicate].has_key?(index)
      cached = node_cache[:string_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_string_directive
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        if has_terminal?('not implemented', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 15))
          @index += 15
        else
          terminal_parse_failure('not implemented')
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(StringPredicate0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:string_predicate][start_index] = r0

    r0
  end

  def _nt_string_directive
    start_index = index
    if node_cache[:string_directive].has_key?(index)
      cached = node_cache[:string_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('not implemented', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 15))
      @index += 15
    else
      terminal_parse_failure('not implemented')
      r0 = nil
    end

    node_cache[:string_directive][start_index] = r0

    r0
  end

  module LogicalPredicate0
    def directive
      elements[0]
    end

    def parameter
      elements[2]
    end
  end

  def _nt_logical_predicate
    start_index = index
    if node_cache[:logical_predicate].has_key?(index)
      cached = node_cache[:logical_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_logical_directive
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_boolean
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LogicalPredicate0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:logical_predicate][start_index] = r0

    r0
  end

  def _nt_logical_directive
    start_index = index
    if node_cache[:logical_directive].has_key?(index)
      cached = node_cache[:logical_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_page_format_logical_directive
    if r1
      r0 = r1
    else
      r2 = _nt_space_logical_directive
      if r2
        r0 = r2
      else
        r3 = _nt_measure_logical_directive
        if r3
          r0 = r3
        else
          r4 = _nt_miscellaneous_logical_directive
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:logical_directive][start_index] = r0

    r0
  end

  module IntegerPredicate0
    def directive
      elements[0]
    end

    def parameter
      elements[2]
    end
  end

  def _nt_integer_predicate
    start_index = index
    if node_cache[:integer_predicate].has_key?(index)
      cached = node_cache[:integer_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_integer_directive
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_integer
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(IntegerPredicate0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:integer_predicate][start_index] = r0

    r0
  end

  def _nt_integer_directive
    start_index = index
    if node_cache[:integer_directive].has_key?(index)
      cached = node_cache[:integer_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_space_integer_directive
    if r1
      r0 = r1
    else
      r2 = _nt_measure_integer_directive
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:integer_directive][start_index] = r0

    r0
  end

  module NumberPredicate0
    def directive
      elements[0]
    end

    def parameter
      elements[2]
    end
  end

  def _nt_number_predicate
    start_index = index
    if node_cache[:number_predicate].has_key?(index)
      cached = node_cache[:number_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_number_directive
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_float
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(NumberPredicate0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:number_predicate][start_index] = r0

    r0
  end

  def _nt_number_directive
    start_index = index
    if node_cache[:number_directive].has_key?(index)
      cached = node_cache[:number_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_space_number_directive

    node_cache[:number_directive][start_index] = r0

    r0
  end

  module LengthPredicate0
    def directive
      elements[0]
    end

    def parameter
      elements[2]
    end
  end

  def _nt_length_predicate
    start_index = index
    if node_cache[:length_predicate].has_key?(index)
      cached = node_cache[:length_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_length_directive
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_length_measure
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LengthPredicate0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:length_predicate][start_index] = r0

    r0
  end

  def _nt_length_directive
    start_index = index
    if node_cache[:length_directive].has_key?(index)
      cached = node_cache[:length_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_page_format_length_directive
    if r1
      r0 = r1
    else
      r2 = _nt_space_length_directive
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:length_directive][start_index] = r0

    r0
  end

  module Boolean0
    def value
      text_value == 'true'
    end
  end

  def _nt_boolean
    start_index = index
    if node_cache[:boolean].has_key?(index)
      cached = node_cache[:boolean][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('true', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('true')
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(Boolean0)
    else
      if has_terminal?('false', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('false')
        r2 = nil
      end
      if r2
        r0 = r2
        r0.extend(Boolean0)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:boolean][start_index] = r0

    r0
  end

  module LengthMeasure0
    def float
      elements[0]
    end

    def unit_of_length
      elements[2]
    end
  end

  module LengthMeasure1
    def value
      Length.new(float.value, unit_of_length.text_value)
    end
  end

  def _nt_length_measure
    start_index = index
    if node_cache[:length_measure].has_key?(index)
      cached = node_cache[:length_measure][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_float
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_field_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_unit_of_length
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LengthMeasure0)
      r0.extend(LengthMeasure1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:length_measure][start_index] = r0

    r0
  end

  def _nt_unit_of_length
    start_index = index
    if node_cache[:unit_of_length].has_key?(index)
      cached = node_cache[:unit_of_length][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('in', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('in')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('cm', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('cm')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?('pt', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('pt')
          r3 = nil
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:unit_of_length][start_index] = r0

    r0
  end

  def _nt_page_format_logical_directive
    start_index = index
    if node_cache[:page_format_logical_directive].has_key?(index)
      cached = node_cache[:page_format_logical_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('landscape', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure('landscape')
      r0 = nil
    end

    node_cache[:page_format_logical_directive][start_index] = r0

    r0
  end

  module PageFormatLengthDirective0
  end

  module PageFormatLengthDirective1
  end

  def _nt_page_format_length_directive
    start_index = index
    if node_cache[:page_format_length_directive].has_key?(index)
      cached = node_cache[:page_format_length_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('page', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('page')
      r2 = nil
    end
    s1 << r2
    if r2
      i3 = index
      if has_terminal?('height', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 6))
        @index += 6
      else
        terminal_parse_failure('height')
        r4 = nil
      end
      if r4
        r3 = r4
      else
        if has_terminal?('width', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('width')
          r5 = nil
        end
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(PageFormatLengthDirective0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i6, s6 = index, []
      i7 = index
      if has_terminal?('top', false, index)
        r8 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure('top')
        r8 = nil
      end
      if r8
        r7 = r8
      else
        if has_terminal?('bot', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 3))
          @index += 3
        else
          terminal_parse_failure('bot')
          r9 = nil
        end
        if r9
          r7 = r9
        else
          if has_terminal?('left', false, index)
            r10 = instantiate_node(SyntaxNode,input, index...(index + 4))
            @index += 4
          else
            terminal_parse_failure('left')
            r10 = nil
          end
          if r10
            r7 = r10
          else
            if has_terminal?('right', false, index)
              r11 = instantiate_node(SyntaxNode,input, index...(index + 5))
              @index += 5
            else
              terminal_parse_failure('right')
              r11 = nil
            end
            if r11
              r7 = r11
            else
              @index = i7
              r7 = nil
            end
          end
        end
      end
      s6 << r7
      if r7
        if has_terminal?('margin', false, index)
          r12 = instantiate_node(SyntaxNode,input, index...(index + 6))
          @index += 6
        else
          terminal_parse_failure('margin')
          r12 = nil
        end
        s6 << r12
      end
      if s6.last
        r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
        r6.extend(PageFormatLengthDirective1)
      else
        @index = i6
        r6 = nil
      end
      if r6
        r0 = r6
      else
        if has_terminal?('indent', false, index)
          r13 = instantiate_node(SyntaxNode,input, index...(index + 6))
          @index += 6
        else
          terminal_parse_failure('indent')
          r13 = nil
        end
        if r13
          r0 = r13
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:page_format_length_directive][start_index] = r0

    r0
  end

  module FontPredicate0
    def directive
      elements[0]
    end

    def parameter
      elements[2]
    end
  end

  def _nt_font_predicate
    start_index = index
    if node_cache[:font_predicate].has_key?(index)
      cached = node_cache[:font_predicate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_font_directive
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_font
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(FontPredicate0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:font_predicate][start_index] = r0

    r0
  end

  module FontDirective0
  end

  module FontDirective1
  end

  def _nt_font_directive
    start_index = index
    if node_cache[:font_directive].has_key?(index)
      cached = node_cache[:font_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    i2 = index
    if has_terminal?('title', false, index)
      r3 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('title')
      r3 = nil
    end
    if r3
      r2 = r3
    else
      if has_terminal?('subtitle', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 8))
        @index += 8
      else
        terminal_parse_failure('subtitle')
        r4 = nil
      end
      if r4
        r2 = r4
      else
        if has_terminal?('composer', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 8))
          @index += 8
        else
          terminal_parse_failure('composer')
          r5 = nil
        end
        if r5
          r2 = r5
        else
          if has_terminal?('parts', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 5))
            @index += 5
          else
            terminal_parse_failure('parts')
            r6 = nil
          end
          if r6
            r2 = r6
          else
            if has_terminal?('tempo', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 5))
              @index += 5
            else
              terminal_parse_failure('tempo')
              r7 = nil
            end
            if r7
              r2 = r7
            else
              if has_terminal?('gchord', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 6))
                @index += 6
              else
                terminal_parse_failure('gchord')
                r8 = nil
              end
              if r8
                r2 = r8
              else
                if has_terminal?('annotation', false, index)
                  r9 = instantiate_node(SyntaxNode,input, index...(index + 10))
                  @index += 10
                else
                  terminal_parse_failure('annotation')
                  r9 = nil
                end
                if r9
                  r2 = r9
                else
                  if has_terminal?('info', false, index)
                    r10 = instantiate_node(SyntaxNode,input, index...(index + 4))
                    @index += 4
                  else
                    terminal_parse_failure('info')
                    r10 = nil
                  end
                  if r10
                    r2 = r10
                  else
                    if has_terminal?('text', false, index)
                      r11 = instantiate_node(SyntaxNode,input, index...(index + 4))
                      @index += 4
                    else
                      terminal_parse_failure('text')
                      r11 = nil
                    end
                    if r11
                      r2 = r11
                    else
                      if has_terminal?('vocal', false, index)
                        r12 = instantiate_node(SyntaxNode,input, index...(index + 5))
                        @index += 5
                      else
                        terminal_parse_failure('vocal')
                        r12 = nil
                      end
                      if r12
                        r2 = r12
                      else
                        if has_terminal?('words', false, index)
                          r13 = instantiate_node(SyntaxNode,input, index...(index + 5))
                          @index += 5
                        else
                          terminal_parse_failure('words')
                          r13 = nil
                        end
                        if r13
                          r2 = r13
                        else
                          @index = i2
                          r2 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    s1 << r2
    if r2
      if has_terminal?('font', false, index)
        r14 = instantiate_node(SyntaxNode,input, index...(index + 4))
        @index += 4
      else
        terminal_parse_failure('font')
        r14 = nil
      end
      s1 << r14
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(FontDirective0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i15, s15 = index, []
      if has_terminal?('setfont-', false, index)
        r16 = instantiate_node(SyntaxNode,input, index...(index + 8))
        @index += 8
      else
        terminal_parse_failure('setfont-')
        r16 = nil
      end
      s15 << r16
      if r16
        if has_terminal?('\G[1-4]', true, index)
          r17 = true
          @index += 1
        else
          r17 = nil
        end
        s15 << r17
      end
      if s15.last
        r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
        r15.extend(FontDirective1)
      else
        @index = i15
        r15 = nil
      end
      if r15
        r0 = r15
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:font_directive][start_index] = r0

    r0
  end

  module Font0
    def num
      elements[1]
    end
  end

  module Font1
    def name
      elements[0]
    end

    def size
      elements[1]
    end
  end

  module Font2
    def value
      FontSpecifier.new(name.text_value, size.empty? ? nil : size.num.value)
    end
  end

  def _nt_font
    start_index = index
    if node_cache[:font].has_key?(index)
      cached = node_cache[:font][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_alphanum
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      i4, s4 = index, []
      s5, i5 = [], index
      loop do
        r6 = _nt_space
        if r6
          s5 << r6
        else
          break
        end
      end
      if s5.empty?
        @index = i5
        r5 = nil
      else
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
      end
      s4 << r5
      if r5
        i7 = index
        r8 = _nt_posint
        if r8
          r7 = r8
        else
          if has_terminal?('*', false, index)
            r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('*')
            r9 = nil
          end
          if r9
            r7 = r9
          else
            @index = i7
            r7 = nil
          end
        end
        s4 << r7
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(Font0)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Font1)
      r0.extend(Font2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:font][start_index] = r0

    r0
  end

  module SpaceLengthDirective0
  end

  module SpaceLengthDirective1
  end

  def _nt_space_length_directive
    start_index = index
    if node_cache[:space_length_directive].has_key?(index)
      cached = node_cache[:space_length_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    i2 = index
    if has_terminal?('top', false, index)
      r3 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('top')
      r3 = nil
    end
    if r3
      r2 = r3
    else
      if has_terminal?('title', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('title')
        r4 = nil
      end
      if r4
        r2 = r4
      else
        if has_terminal?('subtitle', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 8))
          @index += 8
        else
          terminal_parse_failure('subtitle')
          r5 = nil
        end
        if r5
          r2 = r5
        else
          if has_terminal?('composer', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 8))
            @index += 8
          else
            terminal_parse_failure('composer')
            r6 = nil
          end
          if r6
            r2 = r6
          else
            if has_terminal?('music', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 5))
              @index += 5
            else
              terminal_parse_failure('music')
              r7 = nil
            end
            if r7
              r2 = r7
            else
              if has_terminal?('parts', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 5))
                @index += 5
              else
                terminal_parse_failure('parts')
                r8 = nil
              end
              if r8
                r2 = r8
              else
                if has_terminal?('vocal', false, index)
                  r9 = instantiate_node(SyntaxNode,input, index...(index + 5))
                  @index += 5
                else
                  terminal_parse_failure('vocal')
                  r9 = nil
                end
                if r9
                  r2 = r9
                else
                  if has_terminal?('words', false, index)
                    r10 = instantiate_node(SyntaxNode,input, index...(index + 5))
                    @index += 5
                  else
                    terminal_parse_failure('words')
                    r10 = nil
                  end
                  if r10
                    r2 = r10
                  else
                    if has_terminal?('text', false, index)
                      r11 = instantiate_node(SyntaxNode,input, index...(index + 4))
                      @index += 4
                    else
                      terminal_parse_failure('text')
                      r11 = nil
                    end
                    if r11
                      r2 = r11
                    else
                      if has_terminal?('info', false, index)
                        r12 = instantiate_node(SyntaxNode,input, index...(index + 4))
                        @index += 4
                      else
                        terminal_parse_failure('info')
                        r12 = nil
                      end
                      if r12
                        r2 = r12
                      else
                        @index = i2
                        r2 = nil
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    s1 << r2
    if r2
      if has_terminal?('space', false, index)
        r13 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('space')
        r13 = nil
      end
      s1 << r13
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(SpaceLengthDirective0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i14, s14 = index, []
      i15 = index
      if has_terminal?('staff', false, index)
        r16 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('staff')
        r16 = nil
      end
      if r16
        r15 = r16
      else
        if has_terminal?('syststaff', false, index)
          r17 = instantiate_node(SyntaxNode,input, index...(index + 9))
          @index += 9
        else
          terminal_parse_failure('syststaff')
          r17 = nil
        end
        if r17
          r15 = r17
        else
          @index = i15
          r15 = nil
        end
      end
      s14 << r15
      if r15
        if has_terminal?('sep', false, index)
          r18 = instantiate_node(SyntaxNode,input, index...(index + 3))
          @index += 3
        else
          terminal_parse_failure('sep')
          r18 = nil
        end
        s14 << r18
      end
      if s14.last
        r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
        r14.extend(SpaceLengthDirective1)
      else
        @index = i14
        r14 = nil
      end
      if r14
        r0 = r14
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:space_length_directive][start_index] = r0

    r0
  end

  def _nt_space_integer_directive
    start_index = index
    if node_cache[:space_integer_directive].has_key?(index)
      cached = node_cache[:space_integer_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('barsperstaff', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 12))
      @index += 12
    else
      terminal_parse_failure('barsperstaff')
      r0 = nil
    end

    node_cache[:space_integer_directive][start_index] = r0

    r0
  end

  def _nt_space_number_directive
    start_index = index
    if node_cache[:space_number_directive].has_key?(index)
      cached = node_cache[:space_number_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('parskipfac', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure('parskipfac')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('lineskipfac', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('lineskipfac')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?('maxshrink', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 9))
          @index += 9
        else
          terminal_parse_failure('maxshrink')
          r3 = nil
        end
        if r3
          r0 = r3
        else
          if has_terminal?('scale', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 5))
            @index += 5
          else
            terminal_parse_failure('scale')
            r4 = nil
          end
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:space_number_directive][start_index] = r0

    r0
  end

  def _nt_space_logical_directive
    start_index = index
    if node_cache[:space_logical_directive].has_key?(index)
      cached = node_cache[:space_logical_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('stretchstaff', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 12))
      @index += 12
    else
      terminal_parse_failure('stretchstaff')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('stretchlast', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('stretchlast')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:space_logical_directive][start_index] = r0

    r0
  end

  def _nt_measure_integer_directive
    start_index = index
    if node_cache[:measure_integer_directive].has_key?(index)
      cached = node_cache[:measure_integer_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('measurefirst', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 12))
      @index += 12
    else
      terminal_parse_failure('measurefirst')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('barnumbers', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 10))
        @index += 10
      else
        terminal_parse_failure('barnumbers')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?('measurenb', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 9))
          @index += 9
        else
          terminal_parse_failure('measurenb')
          r3 = nil
        end
        if r3
          r0 = r3
        else
          if has_terminal?('setbarnb', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 8))
            @index += 8
          else
            terminal_parse_failure('setbarnb')
            r4 = nil
          end
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:measure_integer_directive][start_index] = r0

    r0
  end

  def _nt_measure_logical_directive
    start_index = index
    if node_cache[:measure_logical_directive].has_key?(index)
      cached = node_cache[:measure_logical_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('measure_box', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure('measure_box')
      r0 = nil
    end

    node_cache[:measure_logical_directive][start_index] = r0

    r0
  end

  def _nt_typeset_text_unit
    start_index = index
    if node_cache[:typeset_text_unit].has_key?(index)
      cached = node_cache[:typeset_text_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_typeset_text_single_line
    if r1
      r0 = r1
    else
      r2 = _nt_typeset_text_multiline
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:typeset_text_unit][start_index] = r0

    r0
  end

  module TypesetTextSingleLine0
  end

  module TypesetTextSingleLine1
    def directive
      elements[1]
    end

    def space
      elements[2]
    end

    def text
      elements[3]
    end
  end

  module TypesetTextSingleLine2
    def value
      @value ||= TypesetTextLine.new(directive.text_value, text.text_value) 
    end
  end

  def _nt_typeset_text_single_line
    start_index = index
    if node_cache[:typeset_text_single_line].has_key?(index)
      cached = node_cache[:typeset_text_single_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('%%', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('%%')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?('text', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 4))
        @index += 4
      else
        terminal_parse_failure('text')
        r3 = nil
      end
      if r3
        r2 = r3
      else
        if has_terminal?('center', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 6))
          @index += 6
        else
          terminal_parse_failure('center')
          r4 = nil
        end
        if r4
          r2 = r4
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
      if r2
        r5 = _nt_space
        s0 << r5
        if r5
          s6, i6 = [], index
          loop do
            i7, s7 = index, []
            i8 = index
            r9 = _nt_end_of_line
            if r9
              r8 = nil
            else
              @index = i8
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s7 << r8
            if r8
              if index < input_length
                r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure("any character")
                r10 = nil
              end
              s7 << r10
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(TypesetTextSingleLine0)
            else
              @index = i7
              r7 = nil
            end
            if r7
              s6 << r7
            else
              break
            end
          end
          if s6.empty?
            @index = i6
            r6 = nil
          else
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          end
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TypesetTextSingleLine1)
      r0.extend(TypesetTextSingleLine2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:typeset_text_single_line][start_index] = r0

    r0
  end

  module TypesetTextMultiline0
    def end_of_line
      elements[2]
    end
  end

  module TypesetTextMultiline1
  end

  module TypesetTextMultiline2
  end

  module TypesetTextMultiline3
    def text
      elements[1]
    end

    def end_of_line
      elements[2]
    end
  end

  module TypesetTextMultiline4
    def end_of_line
      elements[2]
    end

    def lines
      elements[3]
    end

  end

  module TypesetTextMultiline5
    def value
      @value ||= lines.elements.inject([]) do |result, line|
        result << TypesetTextLine.new('', line.text.text_value)
      end
    end
  end

  def _nt_typeset_text_multiline
    start_index = index
    if node_cache[:typeset_text_multiline].has_key?(index)
      cached = node_cache[:typeset_text_multiline][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('%%begintext', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure('%%begintext')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_end_of_line
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            if has_terminal?('%%', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('%%')
              r7 = nil
            end
            s6 << r7
            if r7
              i8, s8 = index, []
              i9 = index
              i10, s10 = index, []
              if has_terminal?('endtext', false, index)
                r11 = instantiate_node(SyntaxNode,input, index...(index + 7))
                @index += 7
              else
                terminal_parse_failure('endtext')
                r11 = nil
              end
              s10 << r11
              if r11
                s12, i12 = [], index
                loop do
                  r13 = _nt_space
                  if r13
                    s12 << r13
                  else
                    break
                  end
                end
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                s10 << r12
                if r12
                  r14 = _nt_end_of_line
                  s10 << r14
                end
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(TypesetTextMultiline0)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r9 = nil
              else
                @index = i9
                r9 = instantiate_node(SyntaxNode,input, index...index)
              end
              s8 << r9
              if r9
                s15, i15 = [], index
                loop do
                  i16, s16 = index, []
                  i17 = index
                  r18 = _nt_end_of_line
                  if r18
                    r17 = nil
                  else
                    @index = i17
                    r17 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s16 << r17
                  if r17
                    if index < input_length
                      r19 = instantiate_node(SyntaxNode,input, index...(index + 1))
                      @index += 1
                    else
                      terminal_parse_failure("any character")
                      r19 = nil
                    end
                    s16 << r19
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(TypesetTextMultiline1)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    s15 << r16
                  else
                    break
                  end
                end
                r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
                s8 << r15
              end
              if s8.last
                r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
                r8.extend(TypesetTextMultiline2)
              else
                @index = i8
                r8 = nil
              end
              s6 << r8
              if r8
                r20 = _nt_end_of_line
                s6 << r20
              end
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(TypesetTextMultiline3)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            if has_terminal?('%%endtext', false, index)
              r21 = instantiate_node(SyntaxNode,input, index...(index + 9))
              @index += 9
            else
              terminal_parse_failure('%%endtext')
              r21 = nil
            end
            s0 << r21
            if r21
              s22, i22 = [], index
              loop do
                r23 = _nt_space
                if r23
                  s22 << r23
                else
                  break
                end
              end
              r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
              s0 << r22
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TypesetTextMultiline4)
      r0.extend(TypesetTextMultiline5)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:typeset_text_multiline][start_index] = r0

    r0
  end

  module WritefieldsField0
    def instruction_field_identifier
      elements[0]
    end

    def writefields
      elements[3]
    end
  end

  module WritefieldsField1
    def value
      @value ||= InstructionField.new(text_value[0], 'writefields', writefields.value)
    end
  end

  def _nt_writefields_field
    start_index = index
    if node_cache[:writefields_field].has_key?(index)
      cached = node_cache[:writefields_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      if has_terminal?('writefields', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('writefields')
        r2 = nil
      end
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_space
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s0 << r3
        if r3
          r5 = _nt_writefields
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(FieldNode,input, i0...index, s0)
      r0.extend(WritefieldsField0)
      r0.extend(WritefieldsField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:writefields_field][start_index] = r0

    r0
  end

  module Writefields0
  end

  module Writefields1
    def chars
      elements[0]
    end

    def remove
      elements[1]
    end
  end

  module Writefields2
    def value
      @value ||= Writefields.new(chars.text_value, remove.empty?)
    end
  end

  def _nt_writefields
    start_index = index
    if node_cache[:writefields].has_key?(index)
      cached = node_cache[:writefields][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      if has_terminal?('\G[A-Za-z]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      i4, s4 = index, []
      s5, i5 = [], index
      loop do
        r6 = _nt_space
        if r6
          s5 << r6
        else
          break
        end
      end
      if s5.empty?
        @index = i5
        r5 = nil
      else
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
      end
      s4 << r5
      if r5
        if has_terminal?('false', false, index)
          r7 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('false')
          r7 = nil
        end
        s4 << r7
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(Writefields0)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Writefields1)
      r0.extend(Writefields2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:writefields][start_index] = r0

    r0
  end

  def _nt_miscellaneous_logical_directive
    start_index = index
    if node_cache[:miscellaneous_logical_directive].has_key?(index)
      cached = node_cache[:miscellaneous_logical_directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('exprabove', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure('exprabove')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('exprbelow', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 9))
        @index += 9
      else
        terminal_parse_failure('exprbelow')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?('graceslurs', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 10))
          @index += 10
        else
          terminal_parse_failure('graceslurs')
          r3 = nil
        end
        if r3
          r0 = r3
        else
          if has_terminal?('infoline', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 8))
            @index += 8
          else
            terminal_parse_failure('infoline')
            r4 = nil
          end
          if r4
            r0 = r4
          else
            if has_terminal?('oneperpage', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 10))
              @index += 10
            else
              terminal_parse_failure('oneperpage')
              r5 = nil
            end
            if r5
              r0 = r5
            else
              if has_terminal?('vocalabove', false, index)
                r6 = instantiate_node(SyntaxNode,input, index...(index + 10))
                @index += 10
              else
                terminal_parse_failure('vocalabove')
                r6 = nil
              end
              if r6
                r0 = r6
              else
                if has_terminal?('freegchord', false, index)
                  r7 = instantiate_node(SyntaxNode,input, index...(index + 10))
                  @index += 10
                else
                  terminal_parse_failure('freegchord')
                  r7 = nil
                end
                if r7
                  r0 = r7
                else
                  if has_terminal?('printtempo', false, index)
                    r8 = instantiate_node(SyntaxNode,input, index...(index + 10))
                    @index += 10
                  else
                    terminal_parse_failure('printtempo')
                    r8 = nil
                  end
                  if r8
                    r0 = r8
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:miscellaneous_logical_directive][start_index] = r0

    r0
  end

  def _nt_decoration_delimiter_bang
    start_index = index
    if node_cache[:decoration_delimiter_bang].has_key?(index)
      cached = node_cache[:decoration_delimiter_bang][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('!', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('!')
      r0 = nil
    end

    node_cache[:decoration_delimiter_bang][start_index] = r0

    r0
  end

  def _nt_decoration_delimiter_plus
    start_index = index
    if node_cache[:decoration_delimiter_plus].has_key?(index)
      cached = node_cache[:decoration_delimiter_plus][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('+', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('+')
      r0 = nil
    end

    node_cache[:decoration_delimiter_plus][start_index] = r0

    r0
  end

  def _nt_decoration_delimiter_both
    start_index = index
    if node_cache[:decoration_delimiter_both].has_key?(index)
      cached = node_cache[:decoration_delimiter_both][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_decoration_delimiter_bang
    if r1
      r0 = r1
    else
      r2 = _nt_decoration_delimiter_plus
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:decoration_delimiter_both][start_index] = r0

    r0
  end

  def _nt_decoration_delimiter_default
    start_index = index
    if node_cache[:decoration_delimiter_default].has_key?(index)
      cached = node_cache[:decoration_delimiter_default][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('!', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('!')
      r0 = nil
    end

    node_cache[:decoration_delimiter_default][start_index] = r0

    r0
  end

  module QuotedString0
  end

  module QuotedString1
    def value_node
      elements[1]
    end

  end

  module QuotedString2
    def value
      value_node.text_value
    end
  end

  def _nt_quoted_string
    start_index = index
    if node_cache[:quoted_string].has_key?(index)
      cached = node_cache[:quoted_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('"', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        i4 = index
        if has_terminal?('"', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r5 = nil
        end
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          if index < input_length
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("any character")
            r6 = nil
          end
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(QuotedString0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?('"', false, index)
          r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r7 = nil
        end
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(QuotedString1)
      r0.extend(QuotedString2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:quoted_string][start_index] = r0

    r0
  end

  module Rationals0
    def rational
      elements[0]
    end

  end

  module Rationals1
    def all_but_last
      elements[0]
    end

    def last
      elements[1]
    end
  end

  module Rationals2
    def value
      v = all_but_last.elements.map { |el| el.rational.value }
      v << last.value
      v
    end
  end

  def _nt_rationals
    start_index = index
    if node_cache[:rationals].has_key?(index)
      cached = node_cache[:rationals][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      r3 = _nt_rational
      s2 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_space
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Rationals0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r6 = _nt_rational
      s0 << r6
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Rationals1)
      r0.extend(Rationals2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rationals][start_index] = r0

    r0
  end

  module Rational0
    def numerator
      elements[0]
    end

    def denominator
      elements[2]
    end
  end

  module Rational1
    def numerator
      super.text_value.to_i
    end
    def denominator
      super.text_value.to_i
    end
    def value
      Rational(numerator, denominator)
    end
  end

  def _nt_rational
    start_index = index
    if node_cache[:rational].has_key?(index)
      cached = node_cache[:rational][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_digit
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      if has_terminal?("/", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("/")
        r3 = nil
      end
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_digit
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Rational0)
      r0.extend(Rational1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rational][start_index] = r0

    r0
  end

  module Integer0
    def sign
      elements[0]
    end

    def wholenum
      elements[1]
    end
  end

  module Integer1
    def value
      (sign.text_value == '-' ? -1 : 1) * wholenum.value
    end
  end

  def _nt_integer
    start_index = index
    if node_cache[:integer].has_key?(index)
      cached = node_cache[:integer][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i2 = index
    if has_terminal?('-', false, index)
      r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('-')
      r3 = nil
    end
    if r3
      r2 = r3
    else
      if has_terminal?('+', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('+')
        r4 = nil
      end
      if r4
        r2 = r4
      else
        @index = i2
        r2 = nil
      end
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r5 = _nt_wholenum
      s0 << r5
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Integer0)
      r0.extend(Integer1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:integer][start_index] = r0

    r0
  end

  module Wholenum0
    def value
      text_value.to_i
    end
  end

  def _nt_wholenum
    start_index = index
    if node_cache[:wholenum].has_key?(index)
      cached = node_cache[:wholenum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_digit
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Wholenum0)
    end

    node_cache[:wholenum][start_index] = r0

    r0
  end

  module Posint0
  end

  module Posint1
    def value
      text_value.to_i
    end
  end

  def _nt_posint
    start_index = index
    if node_cache[:posint].has_key?(index)
      cached = node_cache[:posint][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[1-9]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Posint0)
      r0.extend(Posint1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:posint][start_index] = r0

    r0
  end

  module Float0
    def integer
      elements[0]
    end

  end

  module Float1
    def integer
      elements[0]
    end

  end

  module Float2
    def integer
      elements[1]
    end
  end

  module Float3
  end

  module Float4
    def value
      text_value.to_f
    end
  end

  def _nt_float
    start_index = index
    if node_cache[:float].has_key?(index)
      cached = node_cache[:float][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    i2, s2 = index, []
    r3 = _nt_integer
    s2 << r3
    if r3
      i4 = index
      if has_terminal?('.', false, index)
        r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('.')
        r5 = nil
      end
      if r5
        r4 = nil
      else
        @index = i4
        r4 = instantiate_node(SyntaxNode,input, index...index)
      end
      s2 << r4
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(Float0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      i6, s6 = index, []
      r7 = _nt_integer
      s6 << r7
      if r7
        if has_terminal?('.', false, index)
          r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('.')
          r8 = nil
        end
        s6 << r8
        if r8
          r10 = _nt_integer
          if r10
            r9 = r10
          else
            r9 = instantiate_node(SyntaxNode,input, index...index)
          end
          s6 << r9
        end
      end
      if s6.last
        r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
        r6.extend(Float1)
      else
        @index = i6
        r6 = nil
      end
      if r6
        r1 = r6
      else
        i11, s11 = index, []
        if has_terminal?('.', false, index)
          r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('.')
          r12 = nil
        end
        s11 << r12
        if r12
          r13 = _nt_integer
          s11 << r13
        end
        if s11.last
          r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
          r11.extend(Float2)
        else
          @index = i11
          r11 = nil
        end
        if r11
          r1 = r11
        else
          @index = i1
          r1 = nil
        end
      end
    end
    s0 << r1
    if r1
      if has_terminal?('', false, index)
        r14 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure('')
        r14 = nil
      end
      s0 << r14
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Float3)
      r0.extend(Float4)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:float][start_index] = r0

    r0
  end

  module Range0
    def first
      elements[0]
    end

    def last
      elements[2]
    end
  end

  module Range1
    def value
      first.value..last.value
    end
  end

  def _nt_range
    start_index = index
    if node_cache[:range].has_key?(index)
      cached = node_cache[:range][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_posint
    s0 << r1
    if r1
      if has_terminal?('-', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('-')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_posint
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Range0)
      r0.extend(Range1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:range][start_index] = r0

    r0
  end

  module KeyFieldLine0
    def key_field
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  def _nt_key_field_line
    start_index = index
    if node_cache[:key_field_line].has_key?(index)
      cached = node_cache[:key_field_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_key_field
    s0 << r1
    if r1
      r2 = _nt_line_ender
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(KeyFieldLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:key_field_line][start_index] = r0

    r0
  end

  def _nt_tune_body
    start_index = index
    if node_cache[:tune_body].has_key?(index)
      cached = node_cache[:tune_body][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_tune_line
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(TuneBodyNode,input, i0...index, s0)
    end

    node_cache[:tune_body][start_index] = r0

    r0
  end

  def _nt_tune_line
    start_index = index
    if node_cache[:tune_line].has_key?(index)
      cached = node_cache[:tune_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_tune_body_field_line
    if r1
      r0 = r1
    else
      r2 = _nt_music_line
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:tune_line][start_index] = r0

    r0
  end

  module MusicLine0
    def tune_element
      elements[1]
    end
  end

  module MusicLine1
    def music_line_ender
      elements[1]
    end
  end

  def _nt_music_line
    start_index = index
    if node_cache[:music_line].has_key?(index)
      cached = node_cache[:music_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      r4 = _nt_music_space
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s2 << r3
      if r3
        r5 = _nt_tune_element
        s2 << r5
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(MusicLine0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r6 = _nt_music_line_ender
      s0 << r6
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MusicLine1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:music_line][start_index] = r0

    r0
  end

  def _nt_tune_element
    start_index = index
    if node_cache[:tune_element].has_key?(index)
      cached = node_cache[:tune_element][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_inline_field
    if r1
      r0 = r1
    else
      r2 = _nt_tuplet_symbol
      if r2
        r0 = r2
      else
        r3 = _nt_slur
        if r3
          r0 = r3
        else
          r4 = _nt_variant_ending
          if r4
            r0 = r4
          else
            r5 = _nt_note_or_chord
            if r5
              r0 = r5
            else
              r6 = _nt_rest
              if r6
                r0 = r6
              else
                r7 = _nt_tie
                if r7
                  r0 = r7
                else
                  r8 = _nt_spacer
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_bar_line
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_overlay_delimiter
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_score_linebreak
                        if r11
                          r0 = r11
                        else
                          r12 = _nt_beam
                          if r12
                            r0 = r12
                          else
                            r13 = _nt_ignored_char
                            if r13
                              r0 = r13
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:tune_element][start_index] = r0

    r0
  end

  def _nt_alphanum
    start_index = index
    if node_cache[:alphanum].has_key?(index)
      cached = node_cache[:alphanum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[A-Za-z0-9_\\-]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:alphanum][start_index] = r0

    r0
  end

  def _nt_digit
    start_index = index
    if node_cache[:digit].has_key?(index)
      cached = node_cache[:digit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[0-9]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:digit][start_index] = r0

    r0
  end

  def _nt_match_nothing
    start_index = index
    if node_cache[:match_nothing].has_key?(index)
      cached = node_cache[:match_nothing][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('[r: unlikely to be matched, and if matched will be rightly ignored]', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 67))
      @index += 67
    else
      terminal_parse_failure('[r: unlikely to be matched, and if matched will be rightly ignored]')
      r0 = nil
    end

    node_cache[:match_nothing][start_index] = r0

    r0
  end

  module AbcFilePreprocess0
    def tune_section_pre
      elements[2]
    end

  end

  def _nt_abc_file_preprocess
    start_index = index
    if node_cache[:abc_file_preprocess].has_key?(index)
      cached = node_cache[:abc_file_preprocess][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_header_section_pre
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        r4 = _nt_text_section
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s0 << r3
      if r3
        r5 = _nt_tune_section_pre
        s0 << r5
        if r5
          s6, i6 = [], index
          loop do
            r7 = _nt_any_section_pre
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(AbcFilePreprocess0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:abc_file_preprocess][start_index] = r0

    r0
  end

  module HeaderSectionPre0
    def any_field_pre
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  module HeaderSectionPre1
    def end_of_section
      elements[2]
    end
  end

  def _nt_header_section_pre
    start_index = index
    if node_cache[:header_section_pre].has_key?(index)
      cached = node_cache[:header_section_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_comment_line
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        i4, s4 = index, []
        r5 = _nt_any_field_pre
        s4 << r5
        if r5
          r6 = _nt_line_ender
          s4 << r6
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(HeaderSectionPre0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
      if r3
        r7 = _nt_end_of_section
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(HeaderSectionPre1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:header_section_pre][start_index] = r0

    r0
  end

  def _nt_any_field_pre
    start_index = index
    if node_cache[:any_field_pre].has_key?(index)
      cached = node_cache[:any_field_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_include_field
    if r1
      r0 = r1
    else
      r2 = _nt_macro_field
      if r2
        r0 = r2
      else
        r3 = _nt_any_other_field_pre
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:any_field_pre][start_index] = r0

    r0
  end

  module IncludeField0
    def instruction_field_identifier
      elements[0]
    end

    def content
      elements[3]
    end
  end

  module IncludeField1
    def value
      @value ||= InstructionField.new(text_value[0], 'abc-include', content.value)
    end
    def inclusion # handles abc-include
      value.inclusion
    end
  end

  def _nt_include_field
    start_index = index
    if node_cache[:include_field].has_key?(index)
      cached = node_cache[:include_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_instruction_field_identifier
    s0 << r1
    if r1
      if has_terminal?("abc-include", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure("abc-include")
        r2 = nil
      end
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_field_space
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s0 << r3
        if r3
          r5 = _nt_string_field_content
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(IncludeField0)
      r0.extend(IncludeField1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:include_field][start_index] = r0

    r0
  end

  module AnyOtherFieldPre0
    def string_field_content
      elements[2]
    end
  end

  def _nt_any_other_field_pre
    start_index = index
    if node_cache[:any_other_field_pre].has_key?(index)
      cached = node_cache[:any_other_field_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[A-Za-z]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?(':', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(':')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_string_field_content
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(AnyOtherFieldPre0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:any_other_field_pre][start_index] = r0

    r0
  end

  module TuneSectionPre0
    def tune_header_pre
      elements[0]
    end

    def tune_body_pre
      elements[1]
    end
  end

  def _nt_tune_section_pre
    start_index = index
    if node_cache[:tune_section_pre].has_key?(index)
      cached = node_cache[:tune_section_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tune_header_pre
    s0 << r1
    if r1
      r2 = _nt_tune_body_pre
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneSectionPre0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_section_pre][start_index] = r0

    r0
  end

  module TuneHeaderPre0
    def any_field_pre
      elements[0]
    end

    def line_ender
      elements[1]
    end
  end

  module TuneHeaderPre1
    def key_field_line
      elements[2]
    end
  end

  def _nt_tune_header_pre
    start_index = index
    if node_cache[:tune_header_pre].has_key?(index)
      cached = node_cache[:tune_header_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_comment_line
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        i4, s4 = index, []
        r5 = _nt_any_field_pre
        s4 << r5
        if r5
          r6 = _nt_line_ender
          s4 << r6
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(TuneHeaderPre0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
      if r3
        r7 = _nt_key_field_line
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TuneHeaderPre1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tune_header_pre][start_index] = r0

    r0
  end

  def _nt_any_section_pre
    start_index = index
    if node_cache[:any_section_pre].has_key?(index)
      cached = node_cache[:any_section_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_tune_section_pre
    if r1
      r0 = r1
    else
      r2 = _nt_text_section
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:any_section_pre][start_index] = r0

    r0
  end

  def _nt_tune_body_pre
    start_index = index
    if node_cache[:tune_body_pre].has_key?(index)
      cached = node_cache[:tune_body_pre][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_match_nothing

    node_cache[:tune_body_pre][start_index] = r0

    r0
  end

end

class ABCParser < Treetop::Runtime::CompiledParser
  include ABC
end


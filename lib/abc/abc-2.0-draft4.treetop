# based on
# http://abc.sourceforge.net/standard/abc2-draft.html

# TODO free text
grammar ABC do
  
  # FILE
  
  # "An ABC file consists of one or more tune transcriptions."
  # "The file may optionally start with a file header."
  # ** We'll loosen this a little and allow 0 or more tunes, ie an empty tunebook is legal
  rule file do
    file_header? tune* <Tunebook>
  end
  
  # "The file header is a block of consecutive field lines, finished by a blank line."
  # "Extended information fields...may appear in the file header"
  rule file_header do
    (info_field / file_field)+ end_of_section <FileHeader>
  end
  
  # FIELDS

  rule file_field do
    (meter_field / other_file_field) line_ender
  end

  rule header_field do
    (meter_field / tempo_field/ unit_length_field / key_field / voice_header_field / other_header_field) line_ender
  end
  
  rule inline_body_field do
    "[" raw_body_field "]"
  end

  rule raw_body_field do
     meter_field / tempo_field / unit_length_field / key_field / lyrics_field / other_body_field
  end

  # TODO: don't fail to parse unrecognized fields
  # but enforce fields not allowed in one or other section...

  rule other_file_field do
    # M already found by earlier rule
    label:[ABCDFGHImNORrSTUZ] ':' value:(!line_ender .)+ <Field>
  end

  rule other_header_field do
    # KMLQV already found by earlier rule
    label:[ABCDFGHImNORRrSTUWXZ] ':' value:(!line_ender .)+ <Field>
  end

  rule other_body_field do
    # KMLQVw already found by earlier rule
    label:[ImNRRrTUWw] ':' space* value:rest_of_tune_field <Field> {
      def value
        super.value
      end
    }
  end

  rule rest_of_tune_field do
    line:(!(line_ender/']'/'\\') .)+ extra:('\\' line_ender recursive:rest_of_tune_field)? {
      def value
        result = line.text_value
        result += extra.recursive.value unless extra.empty?
        result
      end
    }
  end

  # METER FIELD
  rule meter_field do
    label:'M' ':' value:(fractional_meter / named_meter) <Field> {
      def meter
        value.meter
      end
    }
  end

  rule fractional_meter do
    num:digit+ "/" denom:digit+ {
      def meter
        @meter ||= Meter.new num.text_value.to_i, denom.text_value.to_i
      end
    }
  end

  rule named_meter do
    ("C|" / "C" / "none") {
      def meter
        return @meter if @meter
        if text_value == "C"
          @meter = Meter.new :common
        elsif text_value == "C|"
          @meter = Meter.new :cut
        else
          @meter = Meter.new :free
        end
      end
    }
  end

  # UNIT LENGTH FIELD

  rule unit_length_field do
    label:'L' ':' value:((num:digit+ "/" denom:digit+) / digit+) <Field> {
      def value
        if super.respond_to? :num
          Rational(super.num.text_value.to_i, super.denom.text_value.to_i)
        else
          Rational(super.text_value.to_i, 1)
        end
      end    
    }
  end

 
  # TEMPO FIELD

  rule tempo_field do
    label:'Q' ':' value_node:tempo_field_value <Field> {
      def value
        v = Tempo.new
        v.beat_parts = value_node.beat_parts
        v.bpm = value_node.bpm
        v.label = value_node.label
        v
      end
    }
  end
  
  rule tempo_field_value do
    label1:(label:quoted_string space+)? 
    beat_node:((rationals/'C') '=')? bpm_node:wholenum 
    label2:(space+ label:quoted_string)? 
    {
      def label
        if !label2.empty?
          label2.label.value
        elsif !label1.empty?
          label1.label.value
        end
      end
      def beat_parts
        if beat_node.empty?
          nil
        else        
          b = beat_node.elements[0]
          if b.text_value == 'C'
            [ Rational(1, 4) ]
          else
            b.value
          end
        end
      end
      def bpm
        bpm_node.value
      end
    }
  end

  # TODO: deal with escaped " ?
  rule quoted_string do
    '"' value_node:(!'"' .)* '"' {
      def value
        value_node.text_value
      end
    }
  end

  rule rationals do
    all_but_last:(rational:rational space+)* last:rational {
      def value
        v = all_but_last.elements.map { |el| el.rational.value }
        v << last.value
        v
      end
    }
  end
  
  rule rational do
    numerator:digit+ "/" denominator:digit+ {
      def numerator
        super.text_value.to_i
      end
      def denominator
        super.text_value.to_i
      end
      def value
        Rational(numerator, denominator)
      end
    }
  end

  rule integer do
    sign:('-'/'+')? wholenum {
      def value
        if (sign.text_value == '-')
          - wholenum.value
        else
          wholenum.value
        end
      end
    }   
  end
  
  rule wholenum do
    digit+ {
      def value
        text_value.to_i
      end
    }
  end

  rule range do
    first:wholenum '-' last:wholenum {
      def first
        super.value
      end
      def last
        super.value
      end
    }
  end


  # KEY

  rule key_field do
    label:'K' ':' value:(key/"none") <Field> {
      def key
        if value.text_value == "none"
          Key::NONE
        else
          value.key
        end
      end
    }
  end

  rule key do
    tonic:([A-G] [\#b]?) 
    mode:(space* value:mode?) 
    extra:(space* items:key_accidental*) 
    clef:(space* node:clef?) {
      def tonic
        super.text_value if super
      end
      def mode
        super.value.text_value if super.value
      end
      def extra_accidentals
        result = {}
        extra.items.elements.each do |acc|
          result[acc.note_letter] = acc.accidental.value
        end
        result
      end
      def clef
        super.node.clef unless super.node.empty?
      end
      def key
        if !@key
          @key = Key.new tonic, mode, extra_accidentals
          @key.clef = clef if clef
        end
        @key
      end
    }
  end

  # maj min m ion aeo mix dor phr lyd loc
  # a bit ugly here because no case-insensitivity support in treetop
  rule mode do
    ( [mM] [aA] [jJ] /
      [mM] [iI] [nN] /
      [iI] [oO] [nN] /
      [aA] [eE] [oO] /
      [mM] [iI] [xX] /
      [dD] [oO] [rR] /
      [pP] [hH] [rR] /
      [lL] [yY] [dD] /
      [lL] [oO] [cC] )
    [A-Za-z]* / 'm' ![A-Za-z]
  end

  rule key_accidental do
    accidental note_letter space* {
      def note_letter
        super.text_value.upcase
      end
    }
  end

  # "3.3 Extended information fields"
  # "They start with the characters %%, possibly followed by spaces, after which the name
  #  of the field follows, followed by a space and the contents of the field."
  rule info_field do
    '%%' space* label:info_field_name space+ value:(!end_of_line .)+ end_of_line <InfoField> {
      def label
        super.text_value
      end
      def value
        super.text_value
      end
    }
  end

  # not specified in the draft, but seems to be alphanumeric plus hyphen
  rule info_field_name do
    # "abc-copyright" / "abc-version" / "abc-creator" / "abc-charset" / "abc-include" / "abc-edited-by" / "score"
    [A-Za-z\-_]+
  end

  # TUNE
  
  # "It is legal to write a tune without a body."
  # ** We'll also allow raw music with no header
  rule tune do
    (tune_header tune_body? / tune_body) end_of_section <Tune>
  end

  # "Extended information fields...may appear in the tune header"
  rule tune_header do
    (info_field / header_field)+ <TuneHeader>
  end

  # TODO allow comment lines
  rule tune_body do
    tune_line+
  end

  rule tune_line do
    (tune_element+ / raw_body_field) tune_line_ender
  end

  rule tune_line_ender do
     '' line_ender <TuneLineBreak> {
       def hard?
         false
       end
     } / '\\' line_ender
  end

  rule tune_element do
    inline_body_field /
    tune_space / tuplet_symbol / slur / variant_ending / notelike_thing / rest / tie / spacer / bar_line / tune_hard_linebreak /
    ignored_char
  end

  rule tune_hard_linebreak do
    '!' <TuneLineBreak> {
       def hard?
         true
       end
    }
  end
  
  # "# $ * ; ? @
  #  To ensure forward compatibility, current software should ignore these characters
  #  when they appear inside or between note groups, possibly giving a warning."
  #
  # "Back quotes ` may be used freely between beamed notes to increase legibility. 
  #  They are ignored by computer programs."
  rule ignored_char do
    "`" / "#" / "$" / "*" / "?" / "@" # TODO: issue warning?
  end

  # need to keep track of this to figure out beaming
  rule tune_space do
    space+ <TuneSpace>
  end
  
  # NOTES AND RESTS

    # TODO annotations and decorations can be interspersed
  rule notelike_thing do
    grace_note_and_or_broken_rhythm? space* chord_annotation:chord_annotation? space* modifiers:(node:(annotation / decoration) space*)* stroke:stroke <NoteOrRest> {
       def broken_rhythm_marker
         child(BrokenRhythm)
       end
       def decorations
         modifiers.elements.inject([]) { |result, el| result << el.node.symbol if el.node.type == :decoration }
       end
       def annotations
         modifiers.elements.inject([]) { |result, el| result << el.node if el.node.type == :annotation }
       end
       def chord_symbol
         chord_annotation.symbol if !chord_annotation.empty?
       end
       def pitch
         stroke.pitch if stroke.respond_to? :pitch
       end
       def note_length_node
         stroke.note_length_node if stroke.respond_to? :note_length_node
       end
       def notes
         stroke.notes if stroke.respond_to? :notes
       end
    }
  end

   rule grace_note_and_or_broken_rhythm do
     grace_note space* broken_rhythm? / broken_rhythm space* grace_note?
   end
 
  rule stroke do
     chord / note
  end

  rule note do
    pitch note_length_node <Note>
  end

  rule pitch do
     accidental:accidental? note_letter octave_shift <PitchNode> {
       def accidental
         super.value if !super.empty?
       end
     } 
  end
  
  ## "The symbols '^', '=' and '_' are used (before a note) to notate respectively a sharp, natural or flat. Double sharps and flats are available with '^^' and '__' "
  rule accidental do
    ("^^" / "^" / "__" / "_" / "=") '' {
      def value
        { "^^" => 2, "^" => 1, "=" => 0, "_" => -1, "__" => -2 }[text_value]
      end
    }
  end

  rule note_letter do
    [A-Ga-g] {
      def octave
        if text_value =~ /[AB]/
          -1
        elsif text_value =~ /[c-g]/
          1
        else
          0
        end
      end
    }
  end

  # "Lower octaves are reached by using 2 commas, 3 commas and so on. 
  #  Higher octaves are written using 2 apostrophes, 3 apostrophes and so on."
  rule octave_shift do
    ("'" / ",")* {
      def value
        text_value.count("'") - text_value.count(",")
      end
    }
  end

  rule rest do
    note_rest / measure_rest
  end

  rule note_rest do
    [xz] note_length_node <Rest>
  end
  
  rule measure_rest do
    "Z" measure_count:digit+ <MeasureRest> {
      attr_accessor :measure_length
      def measure_count
        super.text_value.to_i
      end
      def note_length
        measure_length * measure_count if measure_length
      end
    }
  end
  
  rule note_length_node do
    numerator:digit* denominator:('/' digits:digit+ / '/'+)? <NoteLength> {
      def numerator
        if !super || super.empty?
          1
        else
          super.text_value.to_i
        end
      end
      def denominator
        if !super || super.empty?         # no denominator: use 1
          1
        elsif !super.respond_to? :digits  # no numeral, only slashes: use 2 ** slash count
          2 ** super.text_value.length
        else                              # numeral: use it
          super.digits.text_value.to_i
        end
      end
      def value
        Rational numerator, denominator
      end
    }  
  end


  # BROKEN RHYTHM MARKERS

  rule broken_rhythm do 
    # TODO: instead of lookahead do postparse check
    ('>'+ / '<'+) &(space* notelike_thing) <BrokenRhythm> {
      # direction = '<' or '>'; which note's timing are you changing?
      def change(direction) 
        x = Rational 1, 2 ** text_value.length
        if text_value[0] == direction
          x
        else 
          2 - x # ie 1 + 1-x; adding time left after shortening the other note
        end
      end
    }
  end


  ## 4.8. REPEAT/BAR SYMBOLS
  ## Bar line symbols are notated as follows:
  ##   |  bar line
  ##   |] thin-thick double bar line
  ##   || thin-thin double bar line
  ##   [| thick-thin double bar line
  ##   |: start of repeated section
  ##   :| end of repeated section
  ##   :: start & end of two repeated sections
  ## If an 'end of repeated section' is found without a previous 'start of repeated section', the music restarts from the beginning of the tune, or from the latest double bar line or end of repeated section.
  ## Note that the notation :: is short for :| followed by |:. The variants ::, :|: and :||: are all equivalent.
  ## By extension, |:: and ::| mean the start and end of a section that is to be repeated three times, and so on.
  ## A dotted bar line can be notated by preceding it with a dot, e.g. '.|'. This may be useful for notating editorial bar lines in music with very long measures. An invisible bar line may be notated by putting the bar line in brackets, e.g. '[|]'. This may be useful for e.g. notating Voice overlay in meter free music.
  ## ABC parsers should be quite liberal in recognizing bar lines. In the wild, bar lines may have any shape, using a sequence of '|' (thin bar line), '[' or ']' (thick bar line), and ':' (dots). Ex: '|[|', '[|:::'.

  rule bar_line
    repeat_before:':'* bar repeat_after:':'* variant_number:wholenum? <BarLine> {
      def type
        bar.type
      end
      def repeat_before
        super.text_value.length
      end
      def repeat_after
        super.text_value.length
      end
      def variant_number
        super.value if !super.empty?
      end
    } /
    '::' <BarLine> {
      def type
        :thin
      end
      def repeat_before
        1
      end
      def repeat_after
        1
      end
    }
  end
  
  rule bar do
    ("[|]" / ".|" / "||" / "[|" / "|]" / "|") '' {
      def type
        bar_types = { 
          '[|]' => :invisible,
          '.|' => :dotted,
          '||' => :double,
          '[|' => :thick_thin,
          '|]' => :thin_thick,
          '|' => :thin,
        }
        bar_types[text_value]
      end
    }
  end


  ## 4.9. FIRST AND SECOND REPEATS
  ## First and second repeats can be notated with the symbols [1 and [2, e.g.
  ##   faf gfe|[1 dfe dBA:|[2 d2e dcB|].
  ## When adjacent to bar lines, these can be shortened to |1 and :|2, but with regard to spaces
  ##   | [1
  ## is legal, while
  ##   | 1
  ## is not.
  ## Thus, a tune with different ending for the first and second repeats has the general form:
  ##   |:  common body of tune  |1  first ending  :|2  second ending  ||
  ## Again, note that in many ABC files the |: will not be present.

  # ** This is implemented by the repeat_number feature of bar_line, above, and by variant_ending, below


  ## 4.10. VARIANT ENDINGS
  ## In combination with P part notation, it is possible to notate more than two variant endings for a section that is to be repeated a number of times.
  ## For example, if the header of the tune contains P:A4.B4 then parts A and B will each be played 4 times. To play a different ending each time, you could write in the tune:
  ##    P:A
  ##    <notes> | [1  <notes>  || [2 <notes> || [3 <notes> || [4 <notes> ||
  ## The Nth ending starts with [N and ends with one of '||', ':|' '|]' or '[|'. You can also mark a section as being used for more than one ending e.g.
  ##    [1,3 <notes> ||
  ## plays on the 1st and 3rd endings and
  ##    [1-3 <notes> ||
  ## plays on endings 1, 2 and 3. In general, '[' can be followed by any list of numbers and ranges as long as it contains no spaces e.g.
  ##    [1,3,5-7  <notes>  || [2,4,8 <notes> ||

  # TODO implement variant endings
  rule variant_ending do
    '[' (range / wholenum) (',' (range / wholenum))* space+
  end

  ## 4.11. TIES AND SLURS
  ## You can tie two notes together either across or within a bar with a '-' symbol, e.g. abc-|cba or abc-cba. More general slurs can be put in with () symbols. Thus (DEFG) puts a slur over the four notes. Spaces within a slur are OK, e.g. ( D E F G ) .
  ## Slurs may be nested:
  ##   (c (d e f) g a)
  ## and they may also start and end on the same note:
  ##   (c d (e) f g a)
  ## An unnested slur on a singe note, e.g. |c d (e) f g a| is legal, but will be ignored.
  ## A dotted slur may be notated by preceding the opening brace with a dot, e.g. .(cde); it is optional to dot the closing brace. Likewise, a dotted tie can be transcribed by preceding it with a dot, e.g. C.-C. This is especially useful in parts with multiple verses: some verses may require a slur, some may not.
  ## It should be noted that although the tie '-' and slur '()' produce similar symbols in staff notation they have completely different meanings to player programs and should not be interchanged. Ties connect two successive notes of the same pitch, causing them to be played as a single note, while slurs connect the first and last note of any series of notes, and may be used to indicate phrasing, or that the group should be played legato. Both ties and slurs may be used into, out of and between chords, and in this case the distinction between them is particularly important.

  rule tie do
    '-' <Tie>
  end

  rule slur do
    ('(' / ')') '' <Slur> {
      def start_slur
        text_value == '('
      end
      def end_slur
        text_value == ')'
      end
    }
  end

  ## 4.12. GRACE NOTES  
  ## Grace notes can be written by enclosing them in curly braces, '{}'. For example, a taorluath on the Highland pipes would be written {GdGe}. The tune 'Athol Brose' (in the file Strspys.abc) has an example of complex Highland pipe gracing in all its glory. Although nominally grace notes have no melodic time value, expressions such as {a3/2b/} or {a>b} can be useful and are legal although some packages may ignore them. The unit duration to use for gracenotes is not specified by the ABC file, but by the package, and might be a specific amount of time (for playback purposes) or a note length (e.g. 1/32 for Highland pipe music, which would allow {ge4d} to code a piobaireachd 'cadence').
  ## To distinguish between appoggiaturas and acciaccaturas, the latter are notated with a forward slash immediately following the open brace, e.g. {/g}C or {/gagab}C:
  # TODO implement this:
  ## The presence of gracenotes is transparent to the broken rhythm construct. Thus the forms A<{g}A and A{g}<A are legal and equivalent to A/2{g}A3/2.

  rule grace_note do
    '{' '/'? note (broken_rhythm? note)* '}'
  end

  # TODO allow broken rhythm notation inside gracenote brackets eg {a>b}



  # DUPLETS, TRIPLETS, QUADRUPLETS, ETC.
  
  ## These can be simply coded with the notation (2ab for a duplet, (3abc for a triplet or (4abcd for a quadruplet, etc, up to (9. The musical meanings are:
  ## (2  2 notes in the time of 3
  ## (3  3 notes in the time of 2
  ## (4  4 notes in the time of 3
  ## (5  5 notes in the time of n
  ## (6  6 notes in the time of 2
  ## (7  7 notes in the time of n
  ## (8  8 notes in the time of 3
  ## (9  9 notes in the time of n
  ## If the time signature is compound (6/8, 9/8, 12/8) then n is three, otherwise n is two.
  ## More general tuplets can be specified using the syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given, it defaults as above. If r is not given, it defaults to p. 

  rule tuplet_symbol do
    '(' p:wholenum extra:(':' q:wholenum? extra:(':' r:wholenum?)?)? <TupletMarker> {
      attr_accessor :compound_meter
      def ratio
        pval = p.value
        if !extra.empty? && !extra.q.empty?
          qval = extra.q.value
        else
          # TODO raise error unless p is 2-9
          qval = "  323n2n3n"[pval]
          if qval != 'n'
            qval = qval.to_i
          elsif compound_meter
            qval = 3
          else
            qval = 2
          end
        end
        Rational(qval, pval);
      end
      def num_notes
        if !extra.empty? && !extra.extra.empty? && !extra.extra.r.empty?
          extra.extra.r.value
        else
          p.value
        end
      end
    }
  end

  # DECORATIONS

  ## Staccato marks (a small dot above or below the note head) can be notated by a dot before the note, i.e. a staccato triplet is written as (3.a.b.c
  ## For fiddlers, the letters u and v can be used to denote up-bow and down-bow, e.g. vAuBvA
  ## Other common symbols are available such as
  ##   ~       Irish roll
  ##   T       trill
  ##   H       fermata
  ##   L       accent or emphasis
  ##   M       lowermordent
  ##   P       uppermordent
  ##   S       segno
  ##   O       coda
  ## However these characters (~.uvTHLMPSO) are just short cuts for commonly used decorations and can even be redefined (see section Redefinable symbols). More generally, symbols can be entered using the syntax +symbol+, e.g. +trill+A4 for a trill symbol (tr).
  rule decoration do
    '+' label:[^+]+ '+' {
      def type
        :decoration
      end
      def symbol
        label.text_value
      end
    }
    /
    [.~H-Wh-w] {
      attr_accessor :user_defined_symbols
      def user_defined_symbols
        @user_defined_symbols || ABC::DEFAULT_USER_DEFINED_SYMBOLS
      end
      def type
        user_defined_symbols[text_value].type if user_defined_symbols[text_value]
      end
      def symbol
        user_defined_symbols[text_value].symbol if type == :decoration
      end
      def text
        user_defined_symbols[text_value].text if type == :annotation
      end
    }
  end

  ## 4.17. CHORDS AND UNISONS
  ## Chords (i.e. more than one note head on a single stem) can be coded with [] symbols around the notes, e.g.
  ## [CEGc]
  ## produces the chord of C major. They can be grouped in beams, e.g.
  ## [d2f2][ce][df]
  ## but there should be no spaces within a chord. See the tune 'Kitchen Girl' in the file Reels.abc for a simple example.
  ## All the notes within a chord should have the same length. More complicated chords can be transcribed with the & operator, see section Voice overlay.
  ## Some packages allow chords with notes of different lengths. However, currenly the semantics of such chords are not well-defined and differ from package to package.
  ## The chord forms a syntactic grouping, to which the same prefixes and postfixes can be attached as to an ordinary note, except for accidentals. In particular, the following notation is legal:
  ## ( "^I" +f+ [CEG]- > [CEG] "^IV" [F=AC]3/2"^V"[GBD]/  H[CEG]2 )
  ## When both inside and outside the chord length modifiers are used, they should be multiplied. I.e. [C2E2G2]3 has the same meaning as [CEG]6.
  ## If the chord contains two notes both of the same length and pitch, such as
  ## [DD]
  ## then it is a unison (e.g. a note played on two strings of a violin simultaneously) and is shown with one stem and two note-heads:

  rule chord do
    '[' notes_node:note+ ']' note_length_node <Chord> {
      def notes
        notes_node.elements
      end
    }
  end


  ## 4.18. CHORD SYMBOLS
  ## Chord symbols (e.g. chords/bass notes) can be put in under the melody line (or above, depending on the package) using double-quotation marks placed to the left of the note it is sounded with, e.g. "Am7"A2D2.
  ## The chord has the format <note><accidental><type></bass>, where <note> can be A-G, the optional <accidental> can be b, #, the optional <type> is one or more of
  ##   m or min        minor
  ##   maj             major
  ##   dim             diminished
  ##   aug or +        augmented
  ##   sus             sustained
  ##   7, 9 ...        7th, 9th, etc.
  ## and </bass> is an optional bass note.
  ## A slash after the chord type is used only if the optional bass note is also used, e.g., "C/E". If the bass note is a regular part of the chord, it indicates the inversion, i.e., which note of the chord is lowest in pitch. If the bass note is not a regular part of the chord, it indicates an additional note that should be sounded with the chord, below it in pitch. The bass note can be any letter (A-G or a-g), with or without a trailing accidental sign (b or #). The case of the letter used for the bass note does not affect the pitch.
  ## Alternate chords can be indicated for printing purposes (but not for playback) by enclosing them in parentheses inside the double-quotation marks after the regular chord, e.g., "G(Em)".
  ## Programs should treat chord symbols quite liberally.

  rule chord_annotation do
    '"' symbol:(chord_symbol space* ('(' chord_symbol ')')?) '"' {
      def symbol
        super.text_value
      end
    }
  end

  rule chord_symbol do
    [A-G] 
    ('b' / '#')? 
    ('m' / 'min' / 'maj' / 'dim' / 'aug' / '+' / 'sus' / wholenum / space)*
    ('/' [A-Ga-g])?
  end


  ##  4.19. ANNOTATIONS
  ##  General text annotations can be added above, below or on the staff in a similar way to chord symbols. In this case, the string within double quotes is preceded by one of five symbols '^', '_', '<', '>' or '@' which controls where the annotation is to be placed; above, below, to the left or right respectively of the following note, rest or bar line. Using the '@' symbol leaves the exact placing of the string to the discretion of the interpreting program. These placement specifiers distinguish annotations from chord symbols, and should prevent programs from attempting to play or transpose them. All text that follows the placement specifier is treated as an ABC string.
  ## Where two or more annotations with the same placement specifier are placed consecutively, e.g. for fingerings, the notation program should draw them on separate lines, with the first listed at the top.
  ## Example:
  ## "<(" ">)" C
  ## Places the note between parentheses.

  rule annotation do
    '"' placement_specifier:('^' / '_' / '<' / '>' / '@') text:(!'"' .)* '"' space* {
      def type
        :annotation
      end
      def placement
        { '^' => :above, '_' => :below, '<' => :left, '>' => :right, '@' => :unspecified }[placement_specifier.text_value]
      end
      def text
        super.text_value
      end
    }
  end


  # LYRICS

  rule lyrics_field do
    label:'w' ':' space* rest_of_lyrics_field <Field> {
      def units
        children(LyricUnit)
      end
      def value
        rest_of_lyrics_field.value
      end
    }
  end

  rule rest_of_lyrics_field do
    line:(!(line_ender / '\\' line_ender) lyric_unit)+ extra:('\\' line_ender recursive:rest_of_lyrics_field)? {
      def value
        result = line.text_value
        result += extra.recursive.value unless extra.empty?
        result
      end
    }
  end

  rule lyric_unit do
    word:("\\-" / [^ _\-\*\|])+ hyphen:(space? '-'+)? stretch:'_'* space* <LyricUnit> {
      attr_reader :skip
      def text
        word.text_value.gsub('\\-', '-').gsub('~', ' ')
      end
      def note_count
        count = 1
        count += stretch.text_value.length if stretch
        count += hyphen.text_value.length - 1 if hyphen && hyphen.text_value.length > 1
        count
      end
      def hyphen?
        !hyphen.empty?
      end
    } /
      ('*' / '|') space* <LyricUnit> {
      def skip
        if text_value[0] == '*'
          :note
        else
          :bar
        end
      end
    }
  end

  rule lyric_divider do
    space+ / line_ender
  end


  ## 6. CLEFS
  ## A clef line specification may be provided in K: and V: fields. The general syntax is:
  ##   [clef=]<clef name>[<line number>][+8 | -8]
  ##     [middle=<pitch>] [transpose=<semitones>]
  ##     [stafflines=<lines>]

  rule clef_transpose do
    ('transpose'/'t') '=' transpose:integer {
      def set_opts(opts)
        opts[:transpose] = transpose.value 
      end
    }
  end

  rule clef_stafflines do
    'stafflines' '=' stafflines:wholenum {
      def set_opts(opts)
        opts[:stafflines] = stafflines.value 
      end
    }
  end

  rule clef_name do
    'clef='? name:[a-zA-Z]+ line_number:wholenum? octave:('+8'/'-8')? {
      def set_opts(opts)
        opts[:name] = name.text_value
        opts[:line_number] = line_number.value unless line_number.empty? 
        opts[:octave] = { '+8' => 1, '-8' => -1 }[octave.text_value] unless octave.empty?
      end
    }
  end

  rule clef_middle do
    ('middle'/'m') '=' middle:pitch {
        def set_opts(opts)
          opts[:middle] = middle
        end
    }
  end

  rule clef_app_specific do
      app:alphanum+ ':' field:alphanum+ '=' value:alphanum+ {
        def set_opts(opts)
          # TODO pass this data to the clef object
        end
      }
  end

  rule clef_specifier do
    clef_transpose / clef_stafflines / clef_middle / clef_app_specific / clef_name
  end

  rule clef do
    first:clef_specifier extras:(space+ specifier:clef_specifier)* {
      def clef
        unless @clef
          opts = {}
          first.set_opts(opts)
          extras.elements.each do |node| 
            node.specifier.set_opts(opts)
          end
          @clef = Clef.new(opts)
        end
        @clef
      end
    }
  end

  # MULTIPLE VOICES

  rule voice_header_field do
    label:'V' ':' id:alphanum+ specifiers:(space+ specifier:voice_specifier)* <Field> {
      def id
        super.text_value
      end
      def voice
        Voice.new(id)
      end
    }
  end

  rule voice_specifiers do
    first:voice_specifier extras:(space+ specifier:voice_specifier)* {
      def array
        result = []
        result << first
        extras.elements.each do |node|
          result << node.specifier
        end
        result
      end
    }
  end

  rule voice_specifier do
    clef_specifier /
    ('name' / 'nm') '=' name:quoted_string /
    ('subname' / 'snm') '=' subname:quoted_string /
    'stem' '=' ('up' / 'down')    
  end

  # TODO find a better place for this

  rule spacer do
    "y" <Spacer>
  end

  # BASICS

  rule alphanum do
    [A-Za-z0-9_\-]
  end

  rule abc_string do
    (!line_ender .)* <ABCString>
  end

  rule blank_line do
    space* end_of_line
  end

  rule line_ender do
    space* comment? end_of_line
  end

  rule space do
    !end_of_line [\s]
  end
  
  rule comment do
    '%' (!end_of_line .)+
  end

  rule end_of_line do
    line_feed / end_of_file
  end

  rule line_feed do
    ("\r"? "\n")
  end

  rule end_of_section do
    blank_line (!end_of_file blank_line)*
  end

  rule end_of_file do
    !.
  end

  rule digit do
    [0-9]
  end

end

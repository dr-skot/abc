# based on
# http://abc.sourceforge.net/standard/abc2-draft.html

# TODO free text
grammar ABC do
  
  # FILE
  
  # "An ABC file consists of one or more tune transcriptions."
  # "The file may optionally start with a file header."
  # ** We'll loosen this a little and allow 0 or more tunes, ie an empty tunebook is legal
  rule file do
    file_header? tune* <Tunebook>
  end
  
  # "The file header is a block of consecutive field lines, finished by a blank line."
  # "Extended information fields...may appear in the file header"
  rule file_header do
    (info_field / file_field)+ end_of_section <FileHeader>
  end
  
  # FIELDS

  rule file_field do
    (meter_field / other_file_field) line_ender
  end

  rule header_field do
    (meter_field / tempo_field/ unit_length_field / key_field / other_header_field) line_ender
  end
  
  rule inline_body_field do
    "[" raw_body_field "]"
  end

  rule raw_body_field do
     meter_field / tempo_field / unit_length_field / key_field / other_body_field
  end

  # TODO: don't fail to parse unrecognized fields
  # but enforce fields not allowed in one or other section...

  rule other_file_field do
    # M already found by earlier rule
    label:[ABCDFGHImNORrSTUZ] ':' value:(!line_ender .)+ <Field>
  end

  rule other_header_field do
    # KMLQ already found by earlier rule
    label:[ABCDFGHImNORRrSTUVWXZ] ':' value:(!line_ender .)+ <Field>
  end

  rule other_body_field do
    # KMLQ already found by earlier rule
    label:[ImNRRrTUVWw] ':' value:(!(line_ender/"]") .)+ <Field>
  end

  # METER FIELD
  rule meter_field do
    label:'M' ':' value:(fractional_meter / named_meter) <Field> {
      def meter
        value.meter
      end
    }
  end

  rule fractional_meter do
    num:digit+ "/" denom:digit+ {
      def meter
        @meter ||= Meter.new num.text_value.to_i, denom.text_value.to_i
      end
    }
  end

  rule named_meter do
    ("C|" / "C" / "none") {
      def meter
        return @meter if @meter
        if text_value == "C"
          @meter = Meter.new :common
        elsif text_value == "C|"
          @meter = Meter.new :cut
        else
          @meter = Meter.new :free
        end
      end
    }
  end

  # UNIT LENGTH FIELD

  rule unit_length_field do
    label:'L' ':' value:((num:digit+ "/" denom:digit+) / digit+) <Field> {
      def value
        if super.respond_to? :num
          Rational(super.num.text_value.to_i, super.denom.text_value.to_i)
        else
          Rational(super.text_value.to_i, 1)
        end
      end    
    }
  end

 
  # TEMPO FIELD

  rule tempo_field do
    label:'Q' ':' value_node:tempo_field_value <Field> {
      def value
        v = Tempo.new
        v.beat_parts = value_node.beat_parts
        v.bpm = value_node.bpm
        v.label = value_node.label
        v
      end
    }
  end
  
  rule tempo_field_value do
    label1:(label:quoted_string space+)? 
    beat_node:((rationals/'C') '=')? bpm_node:integer 
    label2:(space+ label:quoted_string)? 
    {
      def label
        if !label2.empty?
          label2.label.value
        elsif !label1.empty?
          label1.label.value
        end
      end
      def beat_parts
        if beat_node.empty?
          nil
        else        
          b = beat_node.elements[0]
          if b.text_value == 'C'
            [ Rational(1, 4) ]
          else
            b.value
          end
        end
      end
      def bpm
        bpm_node.value
      end
    }
  end

  # TODO: deal with escaped " ?
  rule quoted_string do
    '"' value_node:(!'"' .)* '"' {
      def value
        value_node.text_value
      end
    }
  end

  rule rationals do
    all_but_last:(rational:rational space+)* last:rational {
      def value
        v = all_but_last.elements.map { |el| el.rational.value }
        v << last.value
        v
      end
    }
  end
  
  rule rational do
    numerator:digit+ "/" denominator:digit+ {
      def numerator
        super.text_value.to_i
      end
      def denominator
        super.text_value.to_i
      end
      def value
        Rational(numerator, denominator)
      end
    }
  end
  
  rule integer do
    digit+ {
      def value
        text_value.to_i
      end
    }
  end


  # KEY

  rule key_field do
    label:'K' ':' value:(key/"none") <Field> {
      def value
        if super.text_value == "none"
          NO_KEY
        else
          super
        end
      end
    }
  end

  rule key do
    tonic:([A-G] [\#b]?) space* mode:[A-Za-z]* space* extras:key_accidental* <KeyNode> {
      def tonic
        super.text_value if super
      end
      def mode
        super.text_value if super
      end
      def extra_accidentals
        result = {}
        extras.elements.each do |acc|
          result[acc.note_letter] = acc.accidental.value
        end
        result
      end
    }
  end

  rule key_accidental do
    accidental note_letter space* {
      def note_letter
        super.text_value.upcase
      end
    }
  end

  # "3.3 Extended information fields"
  # "They start with the characters %%, possibly followed by spaces, after which the name
  #  of the field follows, followed by a space and the contents of the field."
  rule info_field do
    '%%' space* label:info_field_name space+ value:(!end_of_line .)+ end_of_line <InfoField> {
      def label
        super.text_value
      end
      def value
        super.text_value
      end
    }
  end

  # not specified in the draft, but seems to be alphanumeric plus hyphen
  rule info_field_name do
    # "abc-copyright" / "abc-version" / "abc-creator" / "abc-charset" / "abc-include" / "abc-edited-by" / "score"
    [A-Za-z\-_]+
  end

  # TUNE
  
  # "It is legal to write a tune without a body."
  # ** We'll also allow raw music with no header
  rule tune do
    (tune_header tune_body? / tune_body) end_of_section <Tune>
  end

  # "Extended information fields...may appear in the tune header"
  rule tune_header do
    (info_field / header_field)+ <TuneHeader>
  end

  # TODO allow comment lines
  rule tune_body do
    tune_line+
  end

  rule tune_line do
    (tune_element+ / raw_body_field) line_ender
  end
  
  rule tune_element do
    inline_body_field /
    tune_space / tuplet_symbol / slur / notelike_thing / rest / broken_rhythm / tie / spacer / bar_line /
    ignored_char
  end

  # "# $ * ; ? @
  #  To ensure forward compatibility, current software should ignore these characters
  #  when they appear inside or between note groups, possibly giving a warning."
  #
  # "Back quotes ` may be used freely between beamed notes to increase legibility. 
  #  They are ignored by computer programs."
  rule ignored_char do
    "`" / "#" / "$" / "*" / "?" / "@" # TODO: issue warning?
  end

  # need to keep track of this to figure out beaming
  rule tune_space do
    space+ <TuneSpace>
  end
  
  # NOTES AND RESTS

    # TODO annotations and decorations can be interspersed
    # TODO these things can be separated by spaces
  rule notelike_thing do
    grace_note? space* chord_annotation:chord_annotation? annotation_nodes:annotation* decoration_nodes:decoration* space* stroke:stroke <NoteOrRest> {
       def decorations
         decoration_nodes.elements.map {|n| n.symbol }
       end
       def annotations
         annotation_nodes.elements
       end
       def chord_symbol
         chord_annotation.symbol if !chord_annotation.empty?
       end
       def pitch
         stroke.pitch if stroke.respond_to? :pitch
       end
       def note_length_node
         stroke.note_length_node if stroke.respond_to? :note_length_node
       end
       def notes
         stroke.notes if stroke.respond_to? :notes
       end
    }
  end
 
  rule stroke do
     chord / note
  end

  rule note do
    pitch note_length_node <Note>
  end

  rule pitch do
    accidental note_letter octave_shift <Pitch>
  end
  
  ## "The symbols '^', '=' and '_' are used (before a note) to notate respectively a sharp, natural or flat. Double sharps and flats are available with '^^' and '__' "
  rule accidental do
    ("^^" / "^" / "__" / "_" / "=")? '' {
      def value
        { "^^" => 2, "^" => 1, "=" => 0, "_" => -1, "__" => -2 }[text_value]
      end
    }
  end

  rule note_letter do
    [A-Ga-g] {
      def octave
        if text_value =~ /[AB]/
          -1
        elsif text_value =~ /[c-g]/
          1
        else
          0
        end
      end
    }
  end

  # "Lower octaves are reached by using 2 commas, 3 commas and so on. 
  #  Higher octaves are written using 2 apostrophes, 3 apostrophes and so on."
  rule octave_shift do
    ("'" / ",")* {
      def value
        text_value.count("'") - text_value.count(",")
      end
    }
  end

  rule rest do
    note_rest / measure_rest
  end

  rule note_rest do
    [xz] note_length_node <Rest>
  end
  
  rule measure_rest do
    "Z" measure_count:digit+ <MeasureRest> {
      attr_accessor :measure_length
      def measure_count
        super.text_value.to_i
      end
      def note_length
        measure_length * measure_count if measure_length
      end
    }
  end
  
  rule note_length_node do
    numerator:digit* denominator:('/' digits:digit+ / '/'+)? <NoteLength> {
      def numerator
        if !super || super.empty?
          1
        else
          super.text_value.to_i
        end
      end
      def denominator
        if !super || super.empty?         # no denominator: use 1
          1
        elsif !super.respond_to? :digits  # no numeral, only slashes: use 2 ** slash count
          2 ** super.text_value.length
        else                              # numeral: use it
          super.digits.text_value.to_i
        end
      end
      def value
        Rational numerator, denominator
      end
    }  
  end


  # BROKEN RHYTHM MARKERS

  rule broken_rhythm do 
    # TODO: instead of lookahead do postparse check
    ('>'+ / '<'+) &(space* notelike_thing) <BrokenRhythm> {
      # direction = '<' or '>'; which note's timing are you changing?
      def change(direction) 
        x = Rational 1, 2 ** text_value.length
        if text_value[0] == direction
          x
        else 
          2 - x # ie 1 + 1-x; adding time left after shortening the other note
        end
      end
    }
  end


  # TIES AND SLURS

  rule tie do
    '-' <Tie>
  end

  rule slur do
    ('(' / ')') '' <Slur> {
      def start_slur
        text_value == '('
      end
      def end_slur
        text_value == ')'
      end
    }
  end

  rule spacer do
    "y" <Spacer>
  end


  # GRACE NOTES
  
  ## Grace notes can be written by enclosing them in curly braces, '{}'. For example, a taorluath on the Highland pipes would be written {GdGe}. The tune 'Athol Brose' (in the file Strspys.abc) has an example of complex Highland pipe gracing in all its glory. Although nominally grace notes have no melodic time value, expressions such as {a3/2b/} or {a>b} can be useful and are legal although some packages may ignore them. The unit duration to use for gracenotes is not specified by the ABC file, but by the package, and might be a specific amount of time (for playback purposes) or a note length (e.g. 1/32 for Highland pipe music, which would allow {ge4d} to code a piobaireachd 'cadence').

  ## To distinguish between appoggiaturas and acciaccaturas, the latter are notated with a forward slash immediately following the open brace, e.g. {/g}C or {/gagab}C:

  rule grace_note do
    '{' '/'? note (broken_rhythm? note)* '}'
  end

  # TODO implement this:
  ## The presence of gracenotes is transparent to the broken rhythm construct. Thus the forms A<{g}A and A{g}<A are legal and equivalent to A/2{g}A3/2.

  # TODO allow broken rhythm notation inside gracenote brackets eg {a>b}



  # DUPLETS, TRIPLETS, QUADRUPLETS, ETC.
  
  ## These can be simply coded with the notation (2ab for a duplet, (3abc for a triplet or (4abcd for a quadruplet, etc, up to (9. The musical meanings are:
  ## (2  2 notes in the time of 3
  ## (3  3 notes in the time of 2
  ## (4  4 notes in the time of 3
  ## (5  5 notes in the time of n
  ## (6  6 notes in the time of 2
  ## (7  7 notes in the time of n
  ## (8  8 notes in the time of 3
  ## (9  9 notes in the time of n
  ## If the time signature is compound (6/8, 9/8, 12/8) then n is three, otherwise n is two.
  ## More general tuplets can be specified using the syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given, it defaults as above. If r is not given, it defaults to p. 

  rule tuplet_symbol do
    '(' p:integer extra:(':' q:integer? extra:(':' r:integer?)?)? <TupletMarker> {
      attr_accessor :compound_meter
      def ratio
        pval = p.value
        if !extra.empty? && !extra.q.empty?
          qval = extra.q.value
        else
          # TODO raise error unless p is 2-9
          qval = "  323n2n3n"[pval]
          if qval != 'n'
            qval = qval.to_i
          elsif compound_meter
            qval = 3
          else
            qval = 2
          end
        end
        Rational(qval, pval);
      end
      def num_notes
        if !extra.empty? && !extra.extra.empty? && !extra.extra.r.empty?
          extra.extra.r.value
        else
          p.value
        end
      end
    }
  end

  # DECORATIONS

  ## Staccato marks (a small dot above or below the note head) can be notated by a dot before the note, i.e. a staccato triplet is written as (3.a.b.c
  ## For fiddlers, the letters u and v can be used to denote up-bow and down-bow, e.g. vAuBvA
  ## Other common symbols are available such as
  ##   ~       Irish roll
  ##   T       trill
  ##   H       fermata
  ##   L       accent or emphasis
  ##   M       lowermordent
  ##   P       uppermordent
  ##   S       segno
  ##   O       coda
  ## However these characters (~.uvTHLMPSO) are just short cuts for commonly used decorations and can even be redefined (see section Redefinable symbols). More generally, symbols can be entered using the syntax +symbol+, e.g. +trill+A4 for a trill symbol (tr).
  rule decoration do
    '+' label:[^+]+ '+' space* {
      def symbol
        label.text_value
      end
    }
  end

  ## 4.17. CHORDS AND UNISONS
  ## Chords (i.e. more than one note head on a single stem) can be coded with [] symbols around the notes, e.g.
  ## [CEGc]
  ## produces the chord of C major. They can be grouped in beams, e.g.
  ## [d2f2][ce][df]
  ## but there should be no spaces within a chord. See the tune 'Kitchen Girl' in the file Reels.abc for a simple example.
  ## All the notes within a chord should have the same length. More complicated chords can be transcribed with the & operator, see section Voice overlay.
  ## Some packages allow chords with notes of different lengths. However, currenly the semantics of such chords are not well-defined and differ from package to package.
  ## The chord forms a syntactic grouping, to which the same prefixes and postfixes can be attached as to an ordinary note, except for accidentals. In particular, the following notation is legal:
  ## ( "^I" +f+ [CEG]- > [CEG] "^IV" [F=AC]3/2"^V"[GBD]/  H[CEG]2 )
  ## When both inside and outside the chord length modifiers are used, they should be multiplied. I.e. [C2E2G2]3 has the same meaning as [CEG]6.
  ## If the chord contains two notes both of the same length and pitch, such as
  ## [DD]
  ## then it is a unison (e.g. a note played on two strings of a violin simultaneously) and is shown with one stem and two note-heads:

  rule chord do
    '[' notes_node:note+ ']' note_length_node <Chord> {
      def notes
        notes_node.elements
      end
    }
  end


  ## 4.18. CHORD SYMBOLS
  ## Chord symbols (e.g. chords/bass notes) can be put in under the melody line (or above, depending on the package) using double-quotation marks placed to the left of the note it is sounded with, e.g. "Am7"A2D2.
  ## The chord has the format <note><accidental><type></bass>, where <note> can be A-G, the optional <accidental> can be b, #, the optional <type> is one or more of
  ##   m or min        minor
  ##   maj             major
  ##   dim             diminished
  ##   aug or +        augmented
  ##   sus             sustained
  ##   7, 9 ...        7th, 9th, etc.
  ## and </bass> is an optional bass note.
  ## A slash after the chord type is used only if the optional bass note is also used, e.g., "C/E". If the bass note is a regular part of the chord, it indicates the inversion, i.e., which note of the chord is lowest in pitch. If the bass note is not a regular part of the chord, it indicates an additional note that should be sounded with the chord, below it in pitch. The bass note can be any letter (A-G or a-g), with or without a trailing accidental sign (b or #). The case of the letter used for the bass note does not affect the pitch.
  ## Alternate chords can be indicated for printing purposes (but not for playback) by enclosing them in parentheses inside the double-quotation marks after the regular chord, e.g., "G(Em)".
  ## Programs should treat chord symbols quite liberally.

  rule chord_annotation do
    '"' symbol:(chord_symbol space* ('(' chord_symbol ')')?) '"' {
      def symbol
        super.text_value
      end
    }
  end

  rule chord_symbol do
    [A-G] 
    ('b' / '#')? 
    ('m' / 'min' / 'maj' / 'dim' / 'aug' / '+' / 'sus' / integer / space)*
    ('/' [A-Ga-g])?
  end


  ##  4.19. ANNOTATIONS
  ##  General text annotations can be added above, below or on the staff in a similar way to chord symbols. In this case, the string within double quotes is preceded by one of five symbols '^', '_', '<', '>' or '@' which controls where the annotation is to be placed; above, below, to the left or right respectively of the following note, rest or bar line. Using the '@' symbol leaves the exact placing of the string to the discretion of the interpreting program. These placement specifiers distinguish annotations from chord symbols, and should prevent programs from attempting to play or transpose them. All text that follows the placement specifier is treated as an ABC string.
  ## Where two or more annotations with the same placement specifier are placed consecutively, e.g. for fingerings, the notation program should draw them on separate lines, with the first listed at the top.
  ## Example:
  ## "<(" ">)" C
  ## Places the note between parentheses.

  rule annotation do
    '"' placement_specifier:('^' / '_' / '<' / '>' / '@') text:(!'"' .)* '"' space* {
      def placement
        { '^' => :above, '_' => :below, '<' => :left, '>' => :right, '@' => :unspecified }[placement_specifier.text_value]
      end
      def text
        super.text_value
      end
    }
  end


  # BAR LINES

  # "ABC parsers should be quite liberal in recognizing bar lines. In the wild, 
  #  bar lines may have any shape, using a sequence of '|' (thin bar line), '[' or ']'
  #  (thick bar line), and ':' (dots). Ex: '|[|', '[|:::'."
  rule bar_line
    repeat_before:(':'*) bar repeat_after:(':'*) <BarLine> {
      def type
        bar.type
      end
      def repeat_before
        super.text_value.length
      end
      def repeat_after
        super.text_value.length
      end
    } /
    '::' {
      def type
        :thin
      end
      def repeat_before
        1
      end
      def repeat_after
        1
      end
    }
  end
  
  rule bar do
    ("[|]" / ".|" / "||" / "[|" / "|]" / "|") '' {
      def type
        bar_types = { 
          '[|]' => :invisible,
          '.|' => :dotted,
          '||' => :double,
          '[|' => :thick_thin,
          '|]' => :thin_thick,
          '|' => :thin,
        }
        bar_types[text_value]
      end
    }
  end

  # BASICS

  rule abc_string do
    (!line_ender .)* <ABCString>
  end

  rule blank_line do
    space* end_of_line
  end

  rule line_ender do
    space* comment? end_of_line
  end

  rule space do
    !end_of_line [\s]
  end
  
  rule comment do
    '%' (!end_of_line .)+
  end

  rule end_of_line do
    line_feed / end_of_file
  end

  rule line_feed do
    ("\r"? "\n")
  end

  rule end_of_section do
    blank_line (!end_of_file blank_line)*
  end

  rule end_of_file do
    !.
  end

  rule digit do
    [0-9]
  end

end

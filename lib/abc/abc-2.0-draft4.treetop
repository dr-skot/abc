# based on
# http://abc.sourceforge.net/standard/abc2-draft.html

# TODO free text
grammar ABC do
  
  # 2.1 Abc file identification
  # All abc files should have the extension ".abc" (all lower-case) on all platforms.
  # Comment: Some web-servers only allow a limited selection of file types; in this case a ".txt" extension is the best alternative.
  # Every abc file should begin with the string %abc. An optional version number may follow on the same line, e.g.
  #   %abc-2.1
  # Version numbers of 2.1 or higher indicate that the abc file is to be interpreted strictly according to the corresponding abc standard; if the version number is missing, the file will be treated under loose interpretation. The version field may also be used to indicate abc versions for individual tunes.
  
  ## TODO deal with this in preprocessor


  # 2.2 Abc file structure
  # An abc file consists of one or more abc tune transcriptions, optionally interspersed with free text and typeset text annotations. It may optionally start with a file header to set up default values for processing the file.
  # The file header, abc tunes and text annotations are separated from each other by empty lines (also known as blank lines).
  # An abc file with more than one tune in it is called an abc tunebook.

  rule abc_file do
    # guarantee at least one tune section, and allow text sections anywhere
    file_header_section? text_section* tune_section (tune_section / text_section)* <Tunebook>
  end

  rule file_header_section do
    file_header end_of_section
  end

  rule text_section do
    (typeset_text / free_text) end_of_section
  end
  
  rule tune_section do
    tune end_of_section
  end
  

  # 2.2.1 Abc tune
  # An abc tune itself consists of a tune header and a tune body, terminated by an empty line or the end of the file. It may also contain comment lines or stylesheet directives.
  # The tune header is composed of several information field lines, which are further discussed in information fields. The tune header should start with an X:(reference number) field followed by a T:(title) field and finish with a K:(key) field.
  # The tune body, which contains the music code, follows immediately after. Certain fields may also be used inside the tune body - see use of fields within the tune body.
  # It is legal to write an abc tune without a tune body. This feature can be used to document tunes without transcribing them.
  # Abc music code lines are those lines in the tune body which give notes, bar lines and other musical symbols - see the tune body for details. In effect, music code is the contents of any line which is not an information field, stylesheet directive or comment line.

  rule tune do
    comment_line* tune_header tune_body? <Tune>
  end

  rule tune_header do
    refnum_field_line title_field_line (extended_info_field / tune_header_line)* key_field_line <TuneHeader>
  end


  # 2.2.2 File header
  # The file may optionally start with a file header (immediately after the version field), consisting of a block of consecutive information fields, stylesheet directives, or both, terminated with an empty line. The file header is used to set default values for the tunes in the file.
  # The file header may only appear at the beginning of a file, not between tunes.
  # Settings in a tune may override the file header settings, but when the end of a tune is reached the defaults set by the file header are reinstated.
  # Applications which extract separate tunes from a file must insert the fields of the original file header into the header of the extracted tune. However, since users may manually extract tunes without regard to the file header, it is not recommended to use a file header in an abc tunebook that is to be distributed.

  # TODO allow stylesheet directives
  rule file_header do
    comment_line* (file_header_field line_ender)+ <FileHeader>
  end


  # 2.2.3 Free text and typeset text
  # The terms free text and typeset text refer to any text not directly included within the information fields in a tune header. Typically such text is used for annotating abc tunebooks; free text is for annotating the abc file but is not included in the typeset score, whereas typeset text is intended for printing out.
  # Free text is just that. It can be included anywhere in an abc file, after the file header, but must be separated from abc tunes, typeset text and the file header by empty lines. Typically it is used for annotating the abc file but in principle can be any text not containing information fields.
  # Comment: Since raw html markup and email headers are treated as free text (provided they don't inadvertently contain information fields) this means that abc software can process a wide variety of text-based input files just by ignoring non-abc code.
  # By default free text is not included in the printed score, although typesetting software may offer the option to print it out (e.g. via a command line switch or GUI checkbox). In this case, the software should treat the free text as a text string, but may format it in any way it chooses.
  # Typeset text is any text specified using text directives. It may be inserted anywhere in an abc file after the file header, either separated from tunes by empty lines, or included in the tune header or tune body.
  # Typeset text should be printed by typesetting programs although its exact position in the printed score is program-dependent.
  # Typeset text that is included in an abc tune (i.e. within the tune header or tune body), must be retained by any programs, such as databasing software, that splits an abc file into separate abc tunes.

  rule typeset_text do
    '%%' (!end_of_line .)+ <TypesetText>
  end

  # TODO make this stricter? technically free text should not contain *any* info fields; this just insures it doesn't start with one
  # TODO ignore comments in free text
  rule free_text do
    !header_start text:(!end_of_section .)+ end_of_line <FreeText> {
      def text
        super.text_value
      end
    }
  end

  rule header_start do
    comment_line* [A-Za-z] ':'
  end


  # 2.2.4 Empty lines and line-breaking
  # Empty lines (also known as blank lines) are used to separate abc tunes, free text and the file header. They also aid the readability of abc files.
  # Lines that consist entirely of white-space (space and tab characters) are also regarded as empty lines.
  # Line-breaks (also known as new lines, line feeds, carriage returns, end-of-lines, etc.) can be used within an abc file to aid readability and, if required, break up long input lines - see continuation of input lines.
  # More specifically, line-breaks in the music code can be used to structure the abc transcription and, by default, generate line-breaks in the printed music. For more details see typesetting line-breaks.

  rule end_of_file do
    !.
  end

  rule line_feed do
    "\r"? "\n"
  end

  rule end_of_line do
    line_feed / end_of_file
  end

  rule space do
    " " / "\t"
  end
  
  rule blank_line do
    space* end_of_line
  end

  rule end_of_section do
    blank_line (!end_of_file blank_line)*
  end



  # 2.2.5 Comments and remarks
  # A percent symbol (%) will cause the remainder of any input line to be ignored. It can be used to add a comment to the end of an abc line or as a comment line in its own right. (To get a percent symbol, type \% - see text strings.)
  # Alternatively, you can use the syntax [r:remark] to write a remark in the middle of a line of music.
  # Example:
  #   |:DEF FED| % this is an end of line comment
  #   % this is a comment line
  #   DEF [r:and this is a remark] FED:|
  # Abc code which contains comments and remarks should be processed in exactly the same way as it would be if all the comments and remarks were removed (although, if the code is preprocessed, and comments are actually removed, the stylesheet directives should be left in place).
  # Important clarification: lines which just contain a comment are processed as if the entire line were removed, even if the comment is preceded by white-space (i.e. the % symbol is the not first character). In other words, removing the comment effectively removes the entire line and so no empty line is introduced.
  
  rule comment do
    '%' (!end_of_line .)+
  end

  rule comment_line do
    space* comment end_of_line
  end

  rule line_ender do
    space* comment? end_of_line comment_line*
  end

  # TODO support '\%' escape sequence
  # TODO differentiate comments from directives
  # TODO should we have special rules for the r: field here?


  # 2.2.6 Continuation of input lines
  # It is sometimes necessary to tell abc software that an input line is continued on the next physical line(s) in the abc file, so that the two (or more) lines are treated as one. In abc 2.0 there was a universal continuation character (see outdated continuations) for this purpose, but it was decided that this was both unnecessary and confusing.
  # In abc 2.1, there are ways of continuing each of the 4 different input line types: music code, information fields, comments and stylesheet directives.
  # In abc music code, by default, line-breaks in the code generate line-breaks in the typeset score and these can be suppressed by using a backslash (or by telling abc typesetting software to ignore line-breaks using I:linebreak $ or I:linebreak <none>) - see typesetting line-breaks for full details.
  # Comment for programmers: The backslash effectively acts as a continuation character for music code lines, although, for those used to encountering it in other computer language contexts, its use is very abc-specific. In particular it can continue music code lines through information fields, comments and stylesheet directives.
  # The 3 other input line types can be continued as follows:
  #   information fields can be continued using +: at the start of the following line - see field continuation;
  #   comments can easily be continued by adding a % symbol at the start of the following line - since they are ignored by abc software it doesn't matter how many lines they are split into;
  #   most stylesheet directives are too short to require a continuation syntax, but if one is required then use the I:<directive> form (see I:instruction), in place of %%<directive> and continue the line as a field - see field continuation.
  # Comment for developers: Unlike other languages, and because of the way in which both information fields and music code can be continued through comments, stylesheet directives and (in the case of music code) information fields, it is generally not possible to parse abc files by pre-processing continuations into single lines.
  # Note that, with the exception of abc music code, continuations are unlikely to be needed often. Indeed in most cases it should be possible, although not necessarily desirable, to write very long input lines, since most abc editing software will display them as wrapped within the text editor window.
  # Recommendation: Despite there being no limit on line length in abc files, it is recommended that users avoid writing abc code with very long lines. In particular, judiciously applied line-breaks can aid the (human) readability of abc code. More importantly, users who send abc tunes with long lines should be aware that email software sometimes introduces additional line-breaks into lines with more than 72 characters and these may even cause errors when the resulting tune is processed.

  rule music_line_ender do
    tune_space? (music_line_break / music_line_continuation)
  end

  rule music_line_break do
    '' line_ender <TuneLineBreak> {
      def hard?
        false
      end
    }
  end

  rule music_line_continuation do
    '\\' line_ender
  end


  # 2.3.1 Embedded abc fragment
  # An abc fragment is a partial abc tune. It may contain a partial tune header with no body or a tune body with optional tune header information fields.
  # Example 1: A fragment with no tune header:
  # <div class="abc-fragment">
  # CDEF GABc|
  # </div>
  # Example 2: A fragment with a partial tune header:
  # <div class="abc-fragment">
  # T:Major scale in D
  # K:D
  # DEFG ABcd|
  # </div>
  # Unless T:, M: and K: fields are present, a fragment is assumed to describe a stave in the treble clef with no title, no meter indication and no key signature, respectively.
  # An abc fragment does not require an empty line to mark the end of the tune body if it is terminated by the document markup.
  # Note for developers: For processing as an abc tune, the parsing code is notionally assumed to add empty X:, T: and K: fields, if these are missing. However, since the processing generally takes place internally within a software package, these need not be added in actuality.

  rule abc_fragment do
    '' (partial_tune_header tune_body? / tune_body) <Tune>
  end

  rule partial_tune_header do
    '' (refnum_field_line? (tune_header_line* key_field_line / tune_header_line+) / refnum_field_line) <TuneHeader>
  end


  # 3. Information fields
  # Any line beginning with a letter in the range A-Z or a-z and immediately followed by a colon (:) is an information field. Information fields are used to notate things such as composer, meter, etc. In fact anything that isn't music.
  # An information field may also be inlined in a tune body when enclosed by [ and ] - see use of fields within the tune body.
  # Many of these information field identifiers are currently unused so, in order to extend the number of information fields in the future, programs that comply with this standard must ignore the occurrence of information fields not defined here (although they should give a non-fatal error message to warn the user, in case the field identifier is an error or is unsupported).
  # Some information fields are permitted only in the file or tune header and some only in the tune body, while others are allowed in both locations. information field identifiers A-G, X-Z and a-g, x-z are not permitted in the body to avoid confusion with note symbols, rests and spacers.
  # Users who wish to use abc notation solely for transcribing (rather than documenting) tunes can ignore most of the information fields. For this purpose all that is really needed are the X:(reference number), T:(title), M:(meter), L:(unit note length) and K:(key) information fields, plus if applicable C:(composer) and w: or W: (words/lyrics, respectively within or after the tune).
  # Recommendation for newcomers: A good way to find out how to use the fields is to look at the example files, sample abc tunes (in particular English.abc), and try out some examples.
  # The information fields are summarised in the following table and discussed in description of information fields and elsewhere.
  # The table illustrates how the information fields may be used in the tune header and whether they may also be used in the tune body (see use of fields within the tune body for details) or in the file header (see abc file structure).
  
  rule any_field do
    special_field / string_field
  end

  rule special_field do
    instruction_field / key_field / unit_note_length_field / meter_field / macro_field / parts_field / tempo_field / symbol_line / user_defined_field / lyrics_field / refnum_field
  end

  rule string_field do
    label:[A-Za-z] ':' content:string_field_content <Field>
  end

  rule string_field_content do
    start:(!line_ender .)* extra:(line_ender '+:' content:string_field_content)? {
      def value
        if extra.empty?
          start.text_value
        else
          start.text_value + ' ' + extra.content.value
        end
      end
    }
  end

  rule file_header_field_excludes do
    [KPQsTVWwX]
  end

  rule tune_header_field_excludes do
    [swXK]
  end

  rule tune_body_field_excludes do
    [A-Ga-gX-Zx-zHOS]
  end
  
  rule file_header_field do
    !file_header_field_excludes any_field
  end
  
  rule tune_header_field do
    voice_header_field / !tune_header_field_excludes any_field
  end

  rule tune_header_line do
    tune_header_field line_ender
  end
  
  rule tune_body_field do
    voice_body_field / !tune_body_field_excludes any_field
  end

  rule tune_body_field_line do
    tune_body_field line_ender
  end

  # TODO move these to later section

  rule inline_field_excludes do
    [A-Ga-gX-Zx-zHOSsTWw]
  end

  rule any_inline_field do
    voice_body_field / special_field / inline_string_field
  end

  rule inline_string_field do
    label:[A-Za-z] ':' content:inline_string_field_content <Field>
  end

  rule inline_string_field_content do
    (!(']'/line_ender) .)+ 
  end

  rule inline_field do
    '[' (!inline_field_excludes any_inline_field) ']'
  end
  

  # 3.1.1 X: - reference number
  # The X: (reference number) field is used to assign to each tune within a tunebook a unique reference number (a positive integer), for example: X:23.
  # The X: field is also used to indicate the start of the tune (and hence the tune header), so all tunes must start with an X: field and only one X: field is allowed per tune.
  # The X: field may be empty, although this is not recommended.
  # Recommendation for developers: Software which writes abc files is recommended to offer users the possibility to manage X: field numbering automatically. GUI applications may even hide the X: field from users although they should always allow the user access to the raw abc file.

  rule refnum_field do
    label:'X' ':' content:integer? <Field>
  end

  rule refnum_field_line do
    refnum_field line_ender
  end

  rule title_field do
    label:'T' ':' content:string_field_content <Field>
  end

  rule title_field_line do
    title_field line_ender
  end

  rule instruction_field do
    'not implemented'
  end

  rule macro_field do
    'not implemented'
  end

  rule parts_field do
    'not implemented'
  end

  rule user_defined_field do
    'not implemented'
  end



  # 3.3 Field continuation
  # A field that is too long for one line may be continued by prefixing +: at the start of the following line. For string-type information fields (see the information fields table for a list of string-type fields), the continuation is considered to add a space between the two half lines.
  # Example: The following two excerpts are considered equivalent.
  # w:Sa-ys my au-l' wan to your aul' wan,
  # +:will~ye come to the Wa-x-ies dar-gle?
  # w:Sa-ys my au-l' wan to your aul' wan, will~ye come to the Wa-x-ies dar-gle?
  # Comment: This is most useful for continuing long w:(aligned lyrics) and H:(history) fields. However, it can also be useful for preventing automatic wrapping by email software (see continuation of input lines).
  # Recommendation for GUI developers: Sometimes users may wish to paste paragraphs of text into an abc file, particularly in the H:(history) field. GUI developers are recommended to provide tools for reformatting such paragraphs, for example by splitting them into several lines each prefixed by +:.
  # There is no limit to the number of times a field may be continued and comments and stylesheet directives may be interspersed between the continuations.
  # Example: The following is a legal continuation of the w: field, although the usage not recommended (the change of font could also be achieved by font specifiers - see font directives).
  # %%vocalfont Times-Roman 14
  # w:nor-mal
  # % legal, but not recommended
  # %%vocalfont Times-Italic *
  # +:i-ta-lic
  # %%vocalfont Times-Roman *
  # +:nor-mal

  rule field_space do
    space / line_ender '+:'
  end
  


  # FIELDS


  # METER FIELD
  rule meter_field do
    label:'M' ':' content:(fractional_meter / named_meter) <Field> {
      def meter
        content.meter
      end
    }
  end

  rule fractional_meter do
    num:digit+ "/" denom:digit+ {
      def meter
        @meter ||= Meter.new num.text_value.to_i, denom.text_value.to_i
      end
    }
  end

  rule named_meter do
    ("C|" / "C" / "none") {
      def meter
        return @meter if @meter
        if text_value == "C"
          @meter = Meter.new :common
        elsif text_value == "C|"
          @meter = Meter.new :cut
        else
          @meter = Meter.new :free
        end
      end
    }
  end

  # UNIT LENGTH FIELD

  rule unit_note_length_field do
    unit_length_field
  end
  rule unit_length_field do
    label:'L' ':' content:((num:digit+ "/" denom:digit+) / digit+) <Field> {
      def value
        if content.respond_to? :num
          Rational(content.num.text_value.to_i, content.denom.text_value.to_i)
        else
          Rational(content.text_value.to_i, 1)
        end
      end    
    }
  end

  
  # TEMPO FIELD

  rule tempo_field do
    label:'Q' ':' content:tempo_field_value <Field> {
      def value
        v = Tempo.new
        v.beat_parts = content.beat_parts
        v.bpm = content.bpm
        v.label = content.label
        v
      end
    }
  end
  
  rule tempo_field_value do
    label1:(label:quoted_string space+)? 
    beat_node:((rationals/'C') '=')? bpm_node:wholenum 
    label2:(space+ label:quoted_string)? 
    {
      def label
        if !label2.empty?
          label2.label.value
        elsif !label1.empty?
          label1.label.value
        end
      end
      def beat_parts
        if beat_node.empty?
          nil
        else        
          b = beat_node.elements[0]
          if b.text_value == 'C'
            [ Rational(1, 4) ]
          else
            b.value
          end
        end
      end
      def bpm
        bpm_node.value
      end
    }
  end

  # TODO: deal with escaped " ?
  rule quoted_string do
    '"' value_node:(!'"' .)* '"' {
      def value
        value_node.text_value
      end
    }
  end

  rule rationals do
    all_but_last:(rational:rational space+)* last:rational {
      def value
        v = all_but_last.elements.map { |el| el.rational.value }
        v << last.value
        v
      end
    }
  end
  
  rule rational do
    numerator:digit+ "/" denominator:digit+ {
      def numerator
        super.text_value.to_i
      end
      def denominator
        super.text_value.to_i
      end
      def value
        Rational(numerator, denominator)
      end
    }
  end

  rule integer do
    sign:('-'/'+')? wholenum {
      def value
        if (sign.text_value == '-')
          - wholenum.value
        else
          wholenum.value
        end
      end
    }   
  end
  
  rule wholenum do
    digit+ {
      def value
        text_value.to_i
      end
    }
  end

  rule range do
    first:wholenum '-' last:wholenum {
      def first
        super.value
      end
      def last
        super.value
      end
    }
  end


  # KEY

  rule key_field do
    label:'K' ':' content:(key/"none") <Field> {
      def key
        if content.text_value == "none"
          Key::NONE
        else
          content.key
        end
      end
    }
  end

  rule key_field_line do
    key_field line_ender
  end


  rule key do
    tonic:([A-G] [\#b]?) 
                  mode:(space* value:mode?) 
                  extra:(space* items:key_accidental*) 
                  clef:(space* node:clef?) {  # TODO should't this be space+?
                    def tonic
                      super.text_value if super
                    end
                    def mode
                      super.value.text_value if super.value
                    end
                    def extra_accidentals
                      result = {}
                      extra.items.elements.each do |acc|
                        result[acc.note_letter] = acc.accidental.value
                      end
                      result
                    end
                    def clef
                      super.node.clef unless super.node.empty?
                    end
                    def key
                      if !@key
                        @key = Key.new tonic, mode, extra_accidentals
                        @key.clef = clef if clef
                      end
                      @key
                    end
                  }
                end

                # maj min m ion aeo mix dor phr lyd loc
                # a bit ugly here because no case-insensitivity support in treetop
                rule mode do
                  ( [mM] [aA] [jJ] /
                    [mM] [iI] [nN] /
                    [iI] [oO] [nN] /
                    [aA] [eE] [oO] /
                    [mM] [iI] [xX] /
                    [dD] [oO] [rR] /
                    [pP] [hH] [rR] /
                    [lL] [yY] [dD] /
                    [lL] [oO] [cC] )
                  [A-Za-z]* / 'm' ![A-Za-z]
  end

  rule key_accidental do
    accidental note_letter space* {
      def note_letter
        super.text_value.upcase
      end
    }
  end

  # "3.3 Extended information fields"
  # "They start with the characters %%, possibly followed by spaces, after which the name
  #  of the field follows, followed by a space and the contents of the field."
  rule extended_info_field do
    '%%' space* label:extended_info_field_name space+ value:(!end_of_line .)+ end_of_line <InfoField> {
      def label
        super.text_value
      end
      def value
        super.text_value
      end
    }
  end

  # not specified in the draft, but seems to be alphanumeric plus hyphen
  rule extended_info_field_name do
    # "abc-copyright" / "abc-version" / "abc-creator" / "abc-charset" / "abc-include" / "abc-edited-by" / "score"
    [A-Za-z\-_]+
  end

  rule key_field_line do
    key_field line_ender
  end

  rule tune_body do
    tune_line+
  end

  rule tune_line do
    tune_body_field_line / music_line
  end

  rule music_line do
    (tune_space? tune_element)+ music_line_ender
  end


  rule tune_element do
    inline_field /
    tuplet_symbol / slur / variant_ending / notelike_thing / rest / tie / spacer / bar_line / overlay_delimiter / tune_hard_linebreak /
    ignored_char
  end

  rule tune_hard_linebreak do
    '!' <TuneLineBreak> {
       def hard?
         true
       end
     }
   end
   
   # "# $ * ; ? @
   #  To ensure forward compatibility, current software should ignore these characters
   #  when they appear inside or between note groups, possibly giving a warning."
   #
   # "Back quotes ` may be used freely between beamed notes to increase legibility. 
   #  They are ignored by computer programs."
   rule ignored_char do
     "`" / "#" / "$" / "*" / "?" / "@" # TODO: issue warning?
   end

   # need to keep track of this to figure out beaming
   rule tune_space do
     space+ <TuneSpace>
   end
   
   # NOTES AND RESTS

   rule notelike_thing do
     grace_note_and_or_broken_rhythm? space* chord_annotation:chord_annotation? space* modifiers:(node:(annotation / decoration) space*)* stroke:stroke <NoteOrRest> {
       def broken_rhythm_marker
         child(BrokenRhythm)
       end
       def decorations
         @decorations ||= modifiers.elements.inject([]) { |result, el| result << el.node.symbol if el.node.type == :decoration }
       end
       def annotations
         @annotations ||= modifiers.elements.inject([]) { |result, el| result << el.node if el.node.type == :annotation }
       end
       def chord_symbol
         if !@chord_symbol
           @chord_symbol = chord_annotation.symbol if !chord_annotation.empty?
         end
         @chord_symbol
       end
       def chord_symbol=(sym)
         @chord_symbol = sym
       end
       def pitch
         stroke.pitch if stroke.respond_to? :pitch
       end
       def note_length_node
         stroke.note_length_node if stroke.respond_to? :note_length_node
       end
       def notes
         stroke.notes if stroke.respond_to? :notes
       end
     }
   end

   rule grace_note_and_or_broken_rhythm do
     grace_note space* broken_rhythm? / broken_rhythm space* grace_note?
   end
   
   rule stroke do
     chord / note
   end

   rule note do
     pitch note_length_node <Note>
   end

   rule pitch do
     accidental:accidental? note_letter octave_shift <PitchNode> {
       def accidental
         super.value if !super.empty?
       end
     } 
   end
   
   ## "The symbols '^', '=' and '_' are used (before a note) to notate respectively a sharp, natural or flat. Double sharps and flats are available with '^^' and '__' "
   rule accidental do
     ("^^" / "^" / "__" / "_" / "=") '' {
       def value
         { "^^" => 2, "^" => 1, "=" => 0, "_" => -1, "__" => -2 }[text_value]
       end
     }
   end

   rule note_letter do
     [A-Ga-g] {
       def octave
         if text_value =~ /[AB]/
           -1
         elsif text_value =~ /[c-g]/
           1
         else
           0
         end
       end
     }
   end

   # "Lower octaves are reached by using 2 commas, 3 commas and so on. 
   #  Higher octaves are written using 2 apostrophes, 3 apostrophes and so on."
   rule octave_shift do
     ("'" / ",")* {
       def value
         text_value.count("'") - text_value.count(",")
       end
     }
   end

   rule rest do
     note_rest / measure_rest
   end

   rule note_rest do
     [xz] note_length_node <Rest>
   end
   
   rule measure_rest do
     "Z" measure_count:digit+ <MeasureRest> {
       attr_accessor :measure_length
       def measure_count
         super.text_value.to_i
       end
       def note_length
         measure_length * measure_count if measure_length
       end
       def broken_rhythm_marker
         nil
       end
     }
   end
   
   rule note_length_node do
     numerator:digit* denominator:('/' digits:digit+ / '/'+)? <NoteLength> {
      def numerator
        if !super || super.empty?
          1
        else
          super.text_value.to_i
        end
      end
      def denominator
        if !super || super.empty?         # no denominator: use 1
          1
        elsif !super.respond_to? :digits  # no numeral, only slashes: use 2 ** slash count
          2 ** super.text_value.length
        else                              # numeral: use it
          super.digits.text_value.to_i
        end
      end
      def value
        Rational numerator, denominator
      end
    }  
  end


  # BROKEN RHYTHM MARKERS

  rule broken_rhythm do 
    # TODO: instead of lookahead do postparse check
    ('>'+ / '<'+) &(space* notelike_thing) <BrokenRhythm> {
      # direction = '<' or '>'; which note's timing are you changing?
      def change(direction) 
        x = Rational 1, 2 ** text_value.length
        if text_value[0] == direction
          x
        else 
          2 - x # ie 1 + 1-x; adding time left after shortening the other note
        end
      end
    }
  end


  ## 4.8. REPEAT/BAR SYMBOLS
  ## Bar line symbols are notated as follows:
  ##   |  bar line
  ##   |] thin-thick double bar line
  ##   || thin-thin double bar line
  ##   [| thick-thin double bar line
  ##   |: start of repeated section
  ##   :| end of repeated section
  ##   :: start & end of two repeated sections
  ## If an 'end of repeated section' is found without a previous 'start of repeated section', the music restarts from the beginning of the tune, or from the latest double bar line or end of repeated section.
  ## Note that the notation :: is short for :| followed by |:. The variants ::, :|: and :||: are all equivalent.
  ## By extension, |:: and ::| mean the start and end of a section that is to be repeated three times, and so on.
  ## A dotted bar line can be notated by preceding it with a dot, e.g. '.|'. This may be useful for notating editorial bar lines in music with very long measures. An invisible bar line may be notated by putting the bar line in brackets, e.g. '[|]'. This may be useful for e.g. notating Voice overlay in meter free music.
  ## ABC parsers should be quite liberal in recognizing bar lines. In the wild, bar lines may have any shape, using a sequence of '|' (thin bar line), '[' or ']' (thick bar line), and ':' (dots). Ex: '|[|', '[|:::'.

  rule bar_line
  repeat_before:':'* bar repeat_after:':'* variant_number:wholenum? <BarLine> {
    def type
      bar.type
    end
    def repeat_before
      super.text_value.length
    end
    def repeat_after
      super.text_value.length
    end
    def variant_number
      super.value if !super.empty?
    end
  } /
    '::' <BarLine> {
    def type
      :thin
    end
    def repeat_before
      1
    end
    def repeat_after
      1
    end
  }
end

rule bar do
  ("[|]" / ".|" / "||" / "[|" / "|]" / "|") '' {
    def type
      bar_types = { 
        '[|]' => :invisible,
        '.|' => :dotted,
        '||' => :double,
        '[|' => :thick_thin,
        '|]' => :thin_thick,
        '|' => :thin,
      }
      bar_types[text_value]
    end
  }
end


## 4.9. FIRST AND SECOND REPEATS
## First and second repeats can be notated with the symbols [1 and [2, e.g.
##   faf gfe|[1 dfe dBA:|[2 d2e dcB|].
## When adjacent to bar lines, these can be shortened to |1 and :|2, but with regard to spaces
##   | [1
## is legal, while
##   | 1
## is not.
## Thus, a tune with different ending for the first and second repeats has the general form:
##   |:  common body of tune  |1  first ending  :|2  second ending  ||
## Again, note that in many ABC files the |: will not be present.

# ** This is implemented by the repeat_number feature of bar_line, above, and by variant_ending, below


## 4.10. VARIANT ENDINGS
## In combination with P part notation, it is possible to notate more than two variant endings for a section that is to be repeated a number of times.
## For example, if the header of the tune contains P:A4.B4 then parts A and B will each be played 4 times. To play a different ending each time, you could write in the tune:
##    P:A
##    <notes> | [1  <notes>  || [2 <notes> || [3 <notes> || [4 <notes> ||
## The Nth ending starts with [N and ends with one of '||', ':|' '|]' or '[|'. You can also mark a section as being used for more than one ending e.g.
##    [1,3 <notes> ||
## plays on the 1st and 3rd endings and
##    [1-3 <notes> ||
## plays on endings 1, 2 and 3. In general, '[' can be followed by any list of numbers and ranges as long as it contains no spaces e.g.
##    [1,3,5-7  <notes>  || [2,4,8 <notes> ||

# TODO implement variant endings
rule variant_ending do
  '[' (range / wholenum) (',' (range / wholenum))* space+
end

## 4.11. TIES AND SLURS
## You can tie two notes together either across or within a bar with a '-' symbol, e.g. abc-|cba or abc-cba. More general slurs can be put in with () symbols. Thus (DEFG) puts a slur over the four notes. Spaces within a slur are OK, e.g. ( D E F G ) .
## Slurs may be nested:
##   (c (d e f) g a)
## and they may also start and end on the same note:
##   (c d (e) f g a)
## An unnested slur on a singe note, e.g. |c d (e) f g a| is legal, but will be ignored.
## A dotted slur may be notated by preceding the opening brace with a dot, e.g. .(cde); it is optional to dot the closing brace. Likewise, a dotted tie can be transcribed by preceding it with a dot, e.g. C.-C. This is especially useful in parts with multiple verses: some verses may require a slur, some may not.
## It should be noted that although the tie '-' and slur '()' produce similar symbols in staff notation they have completely different meanings to player programs and should not be interchanged. Ties connect two successive notes of the same pitch, causing them to be played as a single note, while slurs connect the first and last note of any series of notes, and may be used to indicate phrasing, or that the group should be played legato. Both ties and slurs may be used into, out of and between chords, and in this case the distinction between them is particularly important.

rule tie do
  '-' <Tie>
end

rule slur do
  ('(' / ')') '' <Slur> {
    def start_slur
      text_value == '('
    end
    def end_slur
      text_value == ')'
    end
  }
end

## 4.12. GRACE NOTES  
## Grace notes can be written by enclosing them in curly braces, '{}'. For example, a taorluath on the Highland pipes would be written {GdGe}. The tune 'Athol Brose' (in the file Strspys.abc) has an example of complex Highland pipe gracing in all its glory. Although nominally grace notes have no melodic time value, expressions such as {a3/2b/} or {a>b} can be useful and are legal although some packages may ignore them. The unit duration to use for gracenotes is not specified by the ABC file, but by the package, and might be a specific amount of time (for playback purposes) or a note length (e.g. 1/32 for Highland pipe music, which would allow {ge4d} to code a piobaireachd 'cadence').
## To distinguish between appoggiaturas and acciaccaturas, the latter are notated with a forward slash immediately following the open brace, e.g. {/g}C or {/gagab}C:
# TODO implement this:
## The presence of gracenotes is transparent to the broken rhythm construct. Thus the forms A<{g}A and A{g}<A are legal and equivalent to A/2{g}A3/2.

rule grace_note do
  '{' '/'? note (broken_rhythm? note)* '}'
end

# TODO allow broken rhythm notation inside gracenote brackets eg {a>b}



# DUPLETS, TRIPLETS, QUADRUPLETS, ETC.

## These can be simply coded with the notation (2ab for a duplet, (3abc for a triplet or (4abcd for a quadruplet, etc, up to (9. The musical meanings are:
## (2  2 notes in the time of 3
## (3  3 notes in the time of 2
## (4  4 notes in the time of 3
## (5  5 notes in the time of n
## (6  6 notes in the time of 2
## (7  7 notes in the time of n
## (8  8 notes in the time of 3
## (9  9 notes in the time of n
## If the time signature is compound (6/8, 9/8, 12/8) then n is three, otherwise n is two.
## More general tuplets can be specified using the syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given, it defaults as above. If r is not given, it defaults to p. 

rule tuplet_symbol do
  '(' p:wholenum extra:(':' q:wholenum? extra:(':' r:wholenum?)?)? <TupletMarker> {
    attr_accessor :compound_meter
    def ratio
      pval = p.value
      if !extra.empty? && !extra.q.empty?
        qval = extra.q.value
      else
        # TODO raise error unless p is 2-9
        qval = "  323n2n3n"[pval]
        if qval != 'n'
          qval = qval.to_i
        elsif compound_meter
          qval = 3
        else
          qval = 2
        end
      end
      Rational(qval, pval);
    end
    def num_notes
      if !extra.empty? && !extra.extra.empty? && !extra.extra.r.empty?
        extra.extra.r.value
      else
        p.value
      end
    end
  }
end

# DECORATIONS

## Staccato marks (a small dot above or below the note head) can be notated by a dot before the note, i.e. a staccato triplet is written as (3.a.b.c
## For fiddlers, the letters u and v can be used to denote up-bow and down-bow, e.g. vAuBvA
## Other common symbols are available such as
##   ~       Irish roll
##   T       trill
##   H       fermata
##   L       accent or emphasis
##   M       lowermordent
##   P       uppermordent
##   S       segno
##   O       coda
## However these characters (~.uvTHLMPSO) are just short cuts for commonly used decorations and can even be redefined (see section Redefinable symbols). More generally, symbols can be entered using the syntax +symbol+, e.g. +trill+A4 for a trill symbol (tr).
rule decoration do
  '+' label:[^+]+ '+' <SymbolUnit> {
    def type
      :decoration
    end
    def symbol
      label.text_value
    end
  }
  /
    [.~H-Wh-w] {
      attr_accessor :user_defined_symbols
      def user_defined_symbols
        @user_defined_symbols || ABC::DEFAULT_USER_DEFINED_SYMBOLS
      end
      def type
        user_defined_symbols[text_value].type if user_defined_symbols[text_value]
      end
      def symbol
        user_defined_symbols[text_value].symbol if type == :decoration
      end
      def text
        user_defined_symbols[text_value].text if type == :annotation
      end
    }
  end

  ## 4.17. CHORDS AND UNISONS
  ## Chords (i.e. more than one note head on a single stem) can be coded with [] symbols around the notes, e.g.
  ## [CEGc]
  ## produces the chord of C major. They can be grouped in beams, e.g.
  ## [d2f2][ce][df]
  ## but there should be no spaces within a chord. See the tune 'Kitchen Girl' in the file Reels.abc for a simple example.
  ## All the notes within a chord should have the same length. More complicated chords can be transcribed with the & operator, see section Voice overlay.
  ## Some packages allow chords with notes of different lengths. However, currenly the semantics of such chords are not well-defined and differ from package to package.
  ## The chord forms a syntactic grouping, to which the same prefixes and postfixes can be attached as to an ordinary note, except for accidentals. In particular, the following notation is legal:
  ## ( "^I" +f+ [CEG]- > [CEG] "^IV" [F=AC]3/2"^V"[GBD]/  H[CEG]2 )
  ## When both inside and outside the chord length modifiers are used, they should be multiplied. I.e. [C2E2G2]3 has the same meaning as [CEG]6.
  ## If the chord contains two notes both of the same length and pitch, such as
  ## [DD]
  ## then it is a unison (e.g. a note played on two strings of a violin simultaneously) and is shown with one stem and two note-heads:

  rule chord do
    '[' notes_node:note+ ']' note_length_node <Chord> {
      def notes
        notes_node.elements
      end
    }
  end


  ## 4.18. CHORD SYMBOLS
  ## Chord symbols (e.g. chords/bass notes) can be put in under the melody line (or above, depending on the package) using double-quotation marks placed to the left of the note it is sounded with, e.g. "Am7"A2D2.
  ## The chord has the format <note><accidental><type></bass>, where <note> can be A-G, the optional <accidental> can be b, #, the optional <type> is one or more of
  ##   m or min        minor
  ##   maj             major
  ##   dim             diminished
  ##   aug or +        augmented
  ##   sus             sustained
  ##   7, 9 ...        7th, 9th, etc.
  ## and </bass> is an optional bass note.
  ## A slash after the chord type is used only if the optional bass note is also used, e.g., "C/E". If the bass note is a regular part of the chord, it indicates the inversion, i.e., which note of the chord is lowest in pitch. If the bass note is not a regular part of the chord, it indicates an additional note that should be sounded with the chord, below it in pitch. The bass note can be any letter (A-G or a-g), with or without a trailing accidental sign (b or #). The case of the letter used for the bass note does not affect the pitch.
  ## Alternate chords can be indicated for printing purposes (but not for playback) by enclosing them in parentheses inside the double-quotation marks after the regular chord, e.g., "G(Em)".
  ## Programs should treat chord symbols quite liberally.

  rule chord_annotation do
    '"' symbol:(chord_symbol space* ('(' chord_symbol ')')?) '"' <SymbolUnit> {
      def type
        :chord_symbol
      end
      def symbol
        super.text_value
      end
    }
  end

  rule chord_symbol do
    [A-G] 
    ('b' / '#')? 
    ('m' / 'min' / 'maj' / 'dim' / 'aug' / '+' / 'sus' / wholenum / space)*
      ('/' [A-Ga-g])?
  end


  ##  4.19. ANNOTATIONS
  ##  General text annotations can be added above, below or on the staff in a similar way to chord symbols. In this case, the string within double quotes is preceded by one of five symbols '^', '_', '<', '>' or '@' which controls where the annotation is to be placed; above, below, to the left or right respectively of the following note, rest or bar line. Using the '@' symbol leaves the exact placing of the string to the discretion of the interpreting program. These placement specifiers distinguish annotations from chord symbols, and should prevent programs from attempting to play or transpose them. All text that follows the placement specifier is treated as an ABC string.
  ## Where two or more annotations with the same placement specifier are placed consecutively, e.g. for fingerings, the notation program should draw them on separate lines, with the first listed at the top.
  ## Example:
  ## "<(" ">)" C
  ## Places the note between parentheses.

  rule annotation do
    '"' placement_specifier:('^' / '_' / '<' / '>' / '@') text:(!'"' .)* '"' space* <SymbolUnit> {
      def type
        :annotation
      end
      def placement
        { '^' => :above, '_' => :below, '<' => :left, '>' => :right, '@' => :unspecified }[placement_specifier.text_value]
      end
      def text
        super.text_value
      end
    }
  end


  # LYRICS

  rule lyrics_field do
    label:'w' ':' (field_space* lyric_unit)+ <LyricsLine> {
      def units
        children(LyricUnit)
      end
      def value
        lyrics.text_value
      end
    }
  end

  rule lyric_unit do
    word:("\\-" / [^ _\-\*\|\n])+ hyphen:(space? '-'+)? stretch:'_'* <LyricUnit> {
      attr_reader :skip
      def text
        word.text_value.gsub('\\-', '-').gsub('~', ' ')
      end
      def note_count
        count = 1
        count += stretch.text_value.length if stretch
        count += hyphen.text_value.length - 1 if hyphen && hyphen.text_value.length > 1
        count
      end
      def hyphen?
        !hyphen.empty?
      end
    } /
      ('*' / '|') space* <LyricUnit> {
      def skip
        if text_value[0] == '*'
          :note
        else
          :bar
        end
      end
    }
  end

  rule lyric_divider do
    space+ / line_ender
  end

  # SYMBOL LINES
  rule symbol_line do
    's' ':' (field_space+ / symbol_skip / chord_annotation / annotation / decoration )+ <SymbolLine>
    end

    rule symbol_skip do
      ('*' / '|') '' <SymbolUnit> {
        def skip
          if text_value == '*'
            :note
          else
            :bar
          end
        end
      }
    end


    ## 6. CLEFS
    ## A clef line specification may be provided in K: and V: fields. The general syntax is:
    ##   [clef=]<clef name>[<line number>][+8 | -8]
    ##     [middle=<pitch>] [transpose=<semitones>]
    ##     [stafflines=<lines>]

    rule clef_transpose do
      ('transpose'/'t') '=' transpose:integer {
        def set_clef_opts(opts)
          opts[:transpose] = transpose.value 
        end
      }
    end

    rule clef_stafflines do
      'stafflines' '=' stafflines:wholenum {
        def set_clef_opts(opts)
          opts[:stafflines] = stafflines.value 
        end
      }
    end

    rule clef_name do
      'clef='? name:[a-zA-Z]+ line_number:wholenum? octave:('+8'/'-8')? {
        def set_clef_opts(opts)
          opts[:name] = name.text_value
          opts[:line_number] = line_number.value unless line_number.empty? 
          opts[:octave] = { '+8' => 1, '-8' => -1 }[octave.text_value] unless octave.empty?
        end
      }
    end

    rule clef_middle do
      ('middle'/'m') '=' middle:pitch {
        def set_clef_opts(opts)
          opts[:middle] = middle
        end
      }
    end

    rule clef_app_specific do
      app:alphanum+ ':' field:alphanum+ '=' value:alphanum+ {
        def set_clef_opts(opts)
          # TODO pass this data to the clef object
        end
      }
    end

    rule clef_specifier do
      clef_transpose / clef_stafflines / clef_middle / clef_app_specific / clef_name
    end

    rule clef do
      first:clef_specifier extras:(space+ specifier:clef_specifier)* {
        def clef
          unless @clef
            opts = {}
            first.set_clef_opts(opts)
            extras.elements.each do |node| 
              node.specifier.set_clef_opts(opts)
            end
            @clef = Clef.new(opts)
          end
          @clef
        end
      }
    end

    # MULTIPLE VOICES

    rule voice_name do
      ('name' / 'nm') '=' name:quoted_string {
        def set_voice_opts(opts)
          opts[:name] = name.value
        end
      }
    end

    rule voice_subname do
      ('subname' / 'snm') '=' subname:quoted_string {
        def set_voice_opts(opts)
          opts[:subname] = subname.value
        end
      }
    end
    
    rule voice_stem do
      'stem' '=' stem:('up' / 'down') {
        def set_voice_opts(opts)
          opts[:stem] = stem.text_value.to_sym
        end
      }
    end

    rule voice_specifier do
      voice_name / voice_subname / voice_stem / clef_specifier
    end

    rule voice_header_field do
      label:'V' ':' id:alphanum+ specifiers:(space+ specifier:voice_specifier)* <Field> {
        def id
          super.text_value[0..19] # first 20 chars only
        end
        def voice
          opts = {}
          specifiers.elements.each do |node|
            node.specifier.set_voice_opts(opts) if node.specifier.respond_to?(:set_voice_opts)
          end
          v = Voice.new(id, opts)
          v.clef = clef
          v
        end
        def clef
          unless @clef
            opts = {}
            specifiers.elements.each do |node|
              node.specifier.set_clef_opts(opts) if node.specifier.respond_to?(:set_clef_opts)
            end
            @clef = Clef.new(opts)
          end
          @clef
        end
      }
    end

    rule voice_body_field do
      label:'V' ':' id:alphanum+ <Field> {
        def id
          super.text_value[0..19] # first 20 chars only
        end
      }
    end

    # VOICE OVERLAYS

    rule overlay_delimiter do
      '&' <OverlayDelimiter> 
    end


    # TODO find a better place for this
    # TODO spacer should be a stroke in the note definition

    rule spacer do
      "y" <Spacer>
    end

    # BASICS

    rule alphanum do
      [A-Za-z0-9_\-]
    end

    rule abc_string do
      (!line_ender .)* <ABCString>
    end

    rule digit do
      [0-9]
    end

  end
